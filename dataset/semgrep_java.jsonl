{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false]}
{"id": "saxparserfactory", "rule": "rules:\n- id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n  languages:\n  - java\n  message: Instantiating SAXParserFactory without disabling entity processing via\n    setFeature functions.\n  patterns:\n  - pattern-either:\n    - pattern: 'SAXParserFactory $SPF =  ... ;\n\n        ...\n\n        SAXParser $SAXPARSER = $SPF.newSAXParser();\n\n        ...\n\n        $SAXPARSER.parse(...);\n\n        '\n    - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n    - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XXX.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\"\\\n      , true);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-general-entities\\\"\\\n      , false);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-parameter-entities\\\"\\\n      , false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: 'SAXParserFactory $SPF = ... ;\n\n      ...\n\n      $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n      '\n  severity: ERROR\n", "failed_tests": ["```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```"], "failed_type": "fp", "testsuite_a": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/xmlReader/vuln\")\n    public String xmlReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n            return \"xmlReader xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/xmlReader/sec\", method = RequestMethod.POST)\n    public String xmlReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n\n            // fix code start\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            //fix code end\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"xmlReader xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/vuln\", method = RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXBuilder builder = new SAXBuilder();\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  // cause xxe\n            return \"SAXBuilder xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/sec\", method = RequestMethod.POST)\n    public String SAXBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder = new SAXBuilder();\n            builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXBuilder xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/vuln\", method = RequestMethod.POST)\n    public String SAXReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXReader reader = new SAXReader();\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body))); // cause xxe\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXReader xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/sec\", method = RequestMethod.POST)\n    public String SAXReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXReader reader = new SAXReader();\n            reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body)));\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXReader xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/Digester/vuln\", method = RequestMethod.POST)\n    public String DigesterVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            Digester digester = new Digester();\n            digester.parse(new StringReader(body));  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"Digester xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/Digester/sec\", method = RequestMethod.POST)\n    public String DigesterSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            Digester digester = new Digester();\n            digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            digester.parse(new StringReader(body));  // parse xml\n\n            return \"Digester xxe security code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // 有回显\n    @RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln01(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // 遍历xml节点name和value\n            StringBuilder buf = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent()));\n                }\n            }\n            sr.close();\n            return buf.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // 有回显\n    @RequestMapping(value = \"/DocumentBuilder/vuln02\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln02(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // 遍历xml节点name和value\n            StringBuilder result = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    // 正常解析XML，需要判断是否是ELEMENT_NODE类型。否则会出现多余的的节点。\n                    if (child.item(j).getNodeType() == Node.ELEMENT_NODE) {\n                        result.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getFirstChild()));\n                    }\n                }\n            }\n            sr.close();\n            return result.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/Sec\", method = RequestMethod.POST)\n    public String DocumentBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            db.parse(is);  // parse xml\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/vuln\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setXIncludeAware(true);   // 支持XInclude\n            dbf.setNamespaceAware(true);  // 支持XInclude\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n            return \"DocumentBuilder xinclude xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/sec\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n            dbf.setXIncludeAware(true);   // 支持XInclude\n            dbf.setNamespaceAware(true);  // 支持XInclude\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xinclude xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/vuln\")\n    public String XMLReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLReader xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/sec\")\n    public String XMLReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"XMLReader xxe security code\";\n    }\n\n\n    /**\n     * 修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY；\n     * 不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。\n     */\n    @PostMapping(\"/DocumentHelper/vuln\")\n    public String DocumentHelper(HttpServletRequest req) {\n        try {\n            String body = WebUtils.getRequestBody(req);\n            DocumentHelper.parseText(body); // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"DocumentHelper xxe vuln code\";\n    }\n\n\n    private static void response(NodeList rootNodeList){\n        for (int i = 0; i < rootNodeList.getLength(); i++) {\n            Node rootNode = rootNodeList.item(i);\n            NodeList xxe = rootNode.getChildNodes();\n            for (int j = 0; j < xxe.getLength(); j++) {\n                Node xxeNode = xxe.item(j);\n                // 测试不能blind xxe，所以强行加了一个回显\n                logger.info(\"xxeNode: \" + xxeNode.getNodeValue());\n            }\n\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "testsuite_b": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "ground_truth": "rules:\n  - id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n    message: >-\n      SAXParserFactory being instantiated without calling the setFeature functions that are generally used for disabling entity\n      processing\n    metadata:\n      cwe: \"CWE-611: Improper Restriction of XML External Entity Reference\"\n      owasp: \"A4: XML External Entities (XXE)\"\n      source-rule-url: https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n      category: security\n    severity: ERROR\n    patterns:\n      # Reference : https://www.programcreek.com/java-api-examples/?api=javax.xml.parsers.SAXParserFactory\n      - pattern-either:\n          - pattern: |\n              SAXParserFactory $SPF =  ... ;\n              ...\n              SAXParser $SAXPARSER = $SPF.newSAXParser();\n              ...\n              $SAXPARSER.parse(...);\n          - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n          - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            ...\n          }\n      - pattern-not-inside: |\n          SAXParserFactory $SPF = ... ;\n          ...\n          $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    languages:\n      - java\n", "rule_path": "extend_dataset/0eed6610/before/saxparserfactory.yaml", "test_path": "extend_dataset/0eed6610/after/saxparserfactory.java", "category": "historical", "splited_testsuite_b": ["```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```", "```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```"], "actual": [true, true], "expected": [true, false]}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false]}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false]}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true]}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false]}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true]}
{"id": "no-string-eqeq", "rule": "rules:\n- equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  id: no-string-eqeq\n  languages:\n  - java\n  message: Strings should not be compared with '=='; use '.equals()' instead.\n  patterns:\n  - pattern: $X == (String $Y)\n  severity: WARNING\n", "failed_tests": ["```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n    }\n}", "testsuite_b": "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}", "ground_truth": "rules:\n- id: no-string-eqeq\n  languages: [java]\n  equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  patterns:\n  - pattern-not: null == (String $Y)\n  - pattern: $X == (String $Y)\n  message: |\n    Strings should not be compared with '=='.\n    This is a reference comparison operator. \n    Use '.equals()' instead.\n  severity: WARNING\n", "rule_path": "extend_dataset/b3e044c0/before/no-string-eqeq.yaml", "test_path": "extend_dataset/b3e044c0/after/no-string-eqeq.java", "category": "historical", "splited_testsuite_b": ["public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (b == 2) return -1;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (null == \"hello\") return 12;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (\"hello\" == null) return 0;\n        return 0;\n    }\n}"], "actual": [true, false, true, true, false], "expected": [true, false, true, false, false]}
{"id": "tainted-system-command", "rule": "rules:\n- id: tainted-system-command\n  languages:\n  - java\n  message: Detected user input entering a method that executes a system command, potentially\n    leading to a command injection vulnerability. This could allow an attacker to\n    inject and execute arbitrary commands on the server, potentially downloading malware\n    or stealing data. Instead, use ProcessBuilder to separate the command into individual\n    arguments, such as `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Ensure\n    the command is hardcoded or restricted to an allowlist to prevent unauthorized\n    execution.\n  mode: taint\n  pattern-sinks:\n  - pattern-either:\n    - pattern: (Runtime $RUNTIME).exec(...)\n    - pattern: (Runtime $RUNTIME).loadLibrary(...)\n    - pattern: Runtime.getRuntime(...).exec(...)\n    - pattern: Runtime.getRuntime(...).loadLibrary(...)\n    - pattern: new ProcessBuilder($ONEARG)\n    - patterns:\n      - pattern: new ProcessBuilder(...)\n      - pattern-not: new ProcessBuilder(\"...\", ...)\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - pattern: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n}"], "failed_type": "fp", "testsuite_a": "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // ruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // ruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        // todoruleid: tainted-system-command\n                        // Indirection, needs interproc taint\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // Case Insensitive\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // e.g Attack\n    // http://localhost:9090/vulnerable/CommandInjectionVulnerability/LEVEL_3?ipaddress=192.168.0.1%20%7c%20cat%20/etc/passwd\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_4, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n    // Payload: 127.0.0.1%0Als\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_%7C_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_5, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\")\n                                        & !requestEntity\n                                                .getUrl()\n                                                .toString()\n                                                .toUpperCase()\n                                                .contains(\"%7C\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @VulnerableAppRequestMapping(\n            value = LevelConstants.LEVEL_6,\n            htmlTemplate = \"LEVEL_1/CI_Level1\",\n            variant = Variant.SECURE)\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && (IP_ADDRESS_PATTERN.matcher(ipAddress).matches()\n                                        || ipAddress.contentEquals(\"localhost\"));\n\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n}\n", "testsuite_b": "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        // todoruleid: tainted-system-command\n                        // Indirection, needs interproc taint\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // Case Insensitive\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // e.g Attack\n    // http://localhost:9090/vulnerable/CommandInjectionVulnerability/LEVEL_3?ipaddress=192.168.0.1%20%7c%20cat%20/etc/passwd\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_4, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n    // Payload: 127.0.0.1%0Als\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_%7C_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_5, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\")\n                                        & !requestEntity\n                                                .getUrl()\n                                                .toString()\n                                                .toUpperCase()\n                                                .contains(\"%7C\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @VulnerableAppRequestMapping(\n            value = LevelConstants.LEVEL_6,\n            htmlTemplate = \"LEVEL_1/CI_Level1\",\n            variant = Variant.SECURE)\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && (IP_ADDRESS_PATTERN.matcher(ipAddress).matches()\n                                        || ipAddress.contentEquals(\"localhost\"));\n\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    public static void test1(@RequestParam(IP_ADDRESS) String ipAddress) {\n        String args = \"ping -c 2 \" + ipAddress + \"test\";\n        Process process;\n        // ruleid: tainted-system-command\n        process = new ProcessBuilder(new String[] {\"sh\", \"-c\", args});\n        process.start();\n    }\n\n    public static void test2(@RequestParam String input) {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n\n    public static void test3(@RequestParam String input) {\n        StringBuilder stringBuilder = new StringBuilder(100);\n        stringBuilder.append(input);\n        stringBuilder.append(\"test2\");\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(stringBuilder);\n    }\n\n    public static void test4(@RequestParam String input) {\n        String test1 = \"test\";\n        String comb = test1.concat(input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n\n    public static void test5(@RequestParam String input) {\n        String test1 = \"test\";\n        String comb = String.format(\"%s%s\", test1, input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}\n", "ground_truth": "rules:\n- id: tainted-system-command\n  languages:\n  - java\n  severity: ERROR\n  mode: taint\n  pattern-propagators:\n  - pattern: (StringBuilder $STRB).append($INPUT)\n    from: $INPUT\n    to: $STRB\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          $METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\n            ...\n          }\n      - pattern-inside: |\n          $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n            ...\n          }\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)\n    - pattern: $SOURCE\n    label: INPUT\n  - patterns:\n    - pattern-either:\n      - pattern: $X + $SOURCE\n      - pattern: $SOURCE + $Y\n      - pattern: (StringBuilder $STRB).append($SOURCE)\n      - pattern: String.format(\"...\", ..., $SOURCE, ...)\n      - pattern: String.join(\"...\", ..., $SOURCE, ...)\n      - pattern: (String $STR).concat($SOURCE)\n      - pattern: $SOURCE.concat(...)\n      - pattern: $X += SOURCE\n      - pattern: $SOURCE += $X\n    label: CONCAT\n    requires: INPUT\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (ProcessBuilder $PB) = new ProcessBuilder(...);\n      - pattern: |\n          (Process $P) = new Process(...);\n      - pattern: |\n          (ProcessBuilder $PB).command(...);\n      - patterns:\n        - pattern-either:\n          - pattern: |\n              (Runtime $R).$EXEC(...);\n          - pattern: |\n               Runtime.getRuntime(...).$EXEC(...);\n        - metavariable-regex:\n            metavariable: $EXEC\n            regex: (exec|loadLibrary|load)\n      - patterns:\n        - pattern: |\n            (ProcessBuilder $PB).command(...).$ADD(...);\n        - metavariable-regex:\n            metavariable: $ADD\n            regex: (add|addAll)\n      - patterns:\n        - pattern-either:\n          - pattern: |\n              $BUILDER = new ProcessBuilder(...);\n              ...\n              $BUILDER.start(...);\n          - pattern: |\n              new ProcessBuilder(...). ... .start(...);\n    requires: CONCAT\n  message: >-\n    Detected user input entering a method which executes a system command.\n    This could result in a command injection vulnerability, which allows an\n    attacker to inject an arbitrary system command onto the server. The attacker\n    could download malware onto or steal data from the server. Instead, use\n    ProcessBuilder, separating the command into individual arguments, like this:\n    `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Further, make sure you\n    hardcode or allowlist the actual command so that attackers can't run arbitrary commands.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - java\n    - spring\n    confidence: HIGH\n    references:\n    - https://www.stackhawk.com/blog/command-injection-java/\n    - https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n    - https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-078/ExecUnescaped.java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    deepsemgrep: true\n", "rule_path": "extend_dataset/20d71bd1/before/tainted-system-command.yaml", "test_path": "extend_dataset/20d71bd1/after/tainted-system-command.java", "category": "historical", "splited_testsuite_b": ["package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test1(@RequestParam(\"ipaddress\") String ipAddress) throws IOException {\n        String args = \"ping -c 2 \" + ipAddress + \"test\";\n        Process process;\n        // ruleid: tainted-system-command\n        process = new ProcessBuilder(new String[] {\"sh\", \"-c\", args}).start();\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test2(@RequestParam String input) throws IOException {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test4(@RequestParam String input) throws IOException {\n        String test1 = \"test\";\n        String comb = test1.concat(input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test5(@RequestParam String input) throws IOException {\n        String test1 = \"test\";\n        String comb = String.format(\"%s%s\", test1, input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(@RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (validator.get()) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(stringBuilder.toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(@RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (validator.get()) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"cmd\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(stringBuilder.toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // deepruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(@RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity) throws ServiceApplicationException, IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress) && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN.matcher(requestEntity.getUrl().toString()).find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(this.getResponseFromPingCommand(ipAddress, validator.get()).toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // deepruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"cmd\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(@RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity) throws ServiceApplicationException, IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress) && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN.matcher(requestEntity.getUrl().toString()).find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(this.getResponseFromPingCommand(ipAddress, validator.get()).toString(), true), HttpStatus.OK);\n    }\n}"], "actual": [true, true, true, true, true, true, true, true], "expected": [true, false, true, true, true, true, true, true]}
{"id": "xmlinputfactory", "rule": "rules:\n- id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n  languages:\n  - java\n  message: '\n\n    XMLInputFactory instantiated without disabling entity processing via setProperty\n    functions.\n\n    '\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XMLFACTORY.setProperty(\\\"\\\n      javax.xml.stream.isSupportingExternalEntities\\\", false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: '$XMLFACTORY = $W.newInstance(...);\n\n      ...\n\n      $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n\n      '\n  - pattern-either:\n    - pattern: $XMLFACTORY = $W.newFactory(...);\n    - pattern: $XMLFACTORY = new XMLInputFactory(...);\n    - pattern: $XMLFACTORY = SAXParserFactory.newInstance(...);\n    - pattern: $XMLFACTORY = DocumentBuilderFactory.newInstance(...);\n  severity: WARNING\n", "failed_tests": ["package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/xmlReader/vuln\")\n    public String xmlReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n            return \"xmlReader xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/xmlReader/sec\", method = RequestMethod.POST)\n    public String xmlReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n\n            // fix code start\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            //fix code end\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"xmlReader xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/vuln\", method = RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXBuilder builder = new SAXBuilder();\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  // cause xxe\n            return \"SAXBuilder xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/sec\", method = RequestMethod.POST)\n    public String SAXBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder = new SAXBuilder();\n            builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXBuilder xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/vuln\", method = RequestMethod.POST)\n    public String SAXReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXReader reader = new SAXReader();\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body))); // cause xxe\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXReader xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/sec\", method = RequestMethod.POST)\n    public String SAXReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXReader reader = new SAXReader();\n            reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body)));\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXReader xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/Digester/vuln\", method = RequestMethod.POST)\n    public String DigesterVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            Digester digester = new Digester();\n            digester.parse(new StringReader(body));  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"Digester xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/Digester/sec\", method = RequestMethod.POST)\n    public String DigesterSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            Digester digester = new Digester();\n            digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            digester.parse(new StringReader(body));  // parse xml\n\n            return \"Digester xxe security code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // 有回显\n    @RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln01(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // 遍历xml节点name和value\n            StringBuilder buf = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent()));\n                }\n            }\n            sr.close();\n            return buf.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // 有回显\n    @RequestMapping(value = \"/DocumentBuilder/vuln02\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln02(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // 遍历xml节点name和value\n            StringBuilder result = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    // 正常解析XML，需要判断是否是ELEMENT_NODE类型。否则会出现多余的的节点。\n                    if (child.item(j).getNodeType() == Node.ELEMENT_NODE) {\n                        result.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getFirstChild()));\n                    }\n                }\n            }\n            sr.close();\n            return result.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/Sec\", method = RequestMethod.POST)\n    public String DocumentBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            db.parse(is);  // parse xml\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/vuln\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setXIncludeAware(true);   // 支持XInclude\n            dbf.setNamespaceAware(true);  // 支持XInclude\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n            return \"DocumentBuilder xinclude xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/sec\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n            dbf.setXIncludeAware(true);   // 支持XInclude\n            dbf.setNamespaceAware(true);  // 支持XInclude\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xinclude xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/vuln\")\n    public String XMLReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLReader xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/sec\")\n    public String XMLReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"XMLReader xxe security code\";\n    }\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n    /**\n     * 修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY；\n     * 不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。\n     */\n    @PostMapping(\"/DocumentHelper/vuln\")\n    public String DocumentHelper(HttpServletRequest req) {\n        try {\n            String body = WebUtils.getRequestBody(req);\n            DocumentHelper.parseText(body); // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"DocumentHelper xxe vuln code\";\n    }\n\n\n    private static void response(NodeList rootNodeList){\n        for (int i = 0; i < rootNodeList.getLength(); i++) {\n            Node rootNode = rootNodeList.item(i);\n            NodeList xxe = rootNode.getChildNodes();\n            for (int j = 0; j < xxe.getLength(); j++) {\n                Node xxeNode = xxe.item(j);\n                // 测试不能blind xxe，所以强行加了一个回显\n                logger.info(\"xxeNode: \" + xxeNode.getNodeValue());\n            }\n\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "testsuite_b": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix1\")\n    public String XMLInputFactoryFix1(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.supportDTD\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix2\")\n    public String XMLInputFactoryFix2(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix3\")\n    public String XMLInputFactoryFix3(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "ground_truth": "rules:\n  - id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n    severity: WARNING\n    metadata:\n      cwe: \"CWE-611: Improper Restriction of XML External Entity Reference\"\n      owasp:\n        - A04:2021 - XML External Entities (XXE)\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n      category: security\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      technology: [java]\n    message:\n      XMLInputFactory being instantiated without calling the setProperty functions\n      that are generally used for disabling entity processing\n    patterns:\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            ...\n          }\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            ...\n          }\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(\"javax.xml.stream.supportDTD\", false);\n            ...\n          }\n      - pattern-not-inside: |\n          $XMLFACTORY = $W.newInstance(...);\n          ...\n          $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n      - pattern-either:\n          - pattern: $XMLFACTORY = XMLInputFactory.newFactory(...);\n          - pattern: $XMLFACTORY = new XMLInputFactory(...);\n          - pattern: $XMLFACTORY = XMLInputFactory.newInstance(...);\n    languages:\n      - java\n", "rule_path": "extend_dataset/5b4e5660/before/xmlinputfactory.yaml", "test_path": "extend_dataset/5b4e5660/after/xmlinputfactory.java", "category": "historical", "splited_testsuite_b": ["package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix1\")\n    public String XMLInputFactoryFix1(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.supportDTD\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix2\")\n    public String XMLInputFactoryFix2(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix3\")\n    public String XMLInputFactoryFix3(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}"], "actual": [false, false, false, false, false], "expected": [true, false, false, false, false]}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false]}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true]}
{"id": "weak-ssl-context", "rule": "rules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  severity: WARNING\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.0\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.1\");\n    }\n\n    public void test4() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.2\");\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "ground_truth": "rules:\n- id: weak-ssl-context\n  metadata:\n    cwe: 'CWE-326: Inadequate Encryption Strength'\n    owasp: 'A3: Sensitive Data Exposure'\n    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT\n    references:\n    - https://tools.ietf.org/html/rfc7568\n    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html\n  message: |\n    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions\n    are considered weak encryption and are deprecated.\n    Use SSLContext.getInstance(\"TLSv1.2\") for the best security.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLSv1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLSv1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLSv1.2\")\n", "rule_path": "extend_dataset/0533282b/before/weak-ssl-context.yaml", "test_path": "extend_dataset/0533282b/after/weak-ssl-context.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "actual": [true, true, true, true, true, true, true, false], "expected": [true, true, true, true, true, false, false, false]}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false]}
{"id": "desede-is-deprecated", "rule": "rules:\n- id: desede-is-deprecated\n  languages:\n  - java\n  - kt\n  message: Triple DES (3DES or DESede) is deprecated. Use AES instead. For details,\n    visit https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA.\n  pattern: $CIPHER.getInstance(\"=~/DESede.*/\")\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}\n", "testsuite_b": "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}\n\n/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}\n\n", "ground_truth": "rules:\n  - id: desede-is-deprecated\n    message: >-\n      Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher.\n      Upgrade to use AES.\n    metadata:\n      cwe: \"CWE-326: Inadequate Encryption Strength\"\n      owasp: \"A3: Sensitive Data Exposure\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n      asvs:\n        section: V6 Stored Cryptography Verification Requirements\n        control_id: 6.2.5 Insecure Algorithm\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      references:\n        - https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    patterns: \n    - pattern-either: \n      - pattern: |\n          $CIPHER.getInstance(\"=~/DESede.*/\")\n      - pattern: |\n          $CRYPTO.KeyGenerator.getInstance(\"DES\")\n    languages:\n      - java\n      - kt\n", "rule_path": "extend_dataset/a7dd64af/before/desede-is-deprecated.yaml", "test_path": "extend_dataset/a7dd64af/after/desede-is-deprecated.java", "category": "historical", "splited_testsuite_b": ["package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}", "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}", "/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}"], "actual": [true, false, false], "expected": [true, false, true]}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false]}
{"id": "disallow-old-tls-versions1", "rule": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "failed_tests": ["class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n", "testsuite_b": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n", "ground_truth": "rules:\n- id: disallow-old-tls-versions1\n  message: >-\n    Detects direct creations of SSLConnectionSocketFactories that don't disallow SSL v2, SSL v3, and TLS\n    v1.\n    SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of trusted\n    certificates.\n    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages: [java]\n  patterns:\n  - pattern: |\n      new SSLConnectionSocketFactory(...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_2). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_3). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n", "rule_path": "extend_dataset/fc9ff9a4/before/disallow-old-tls-versions1.yaml", "test_path": "extend_dataset/fc9ff9a4/after/disallow-old-tls-versions1.java", "category": "historical", "splited_testsuite_b": ["class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "actual": [true, true, true, false, false, false, true], "expected": [true, true, true, false, false, false, false]}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false]}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false]}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true]}
