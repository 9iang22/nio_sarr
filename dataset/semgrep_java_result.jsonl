{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987821364e07ef8922a772e1a8aa6b8c3ca8d6ec4c9a1\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher` class and therefore should not trigger the rule. The rule is intended to catch insecure uses of `Cipher.getInstance(\\\"AES\\\")`, but it currently matches any method named `getInstance` with the argument `\\\"AES\\\"`. To exclude `KeyGenerator.getInstance(\\\"AES\\\")` from triggering the rule, we can use the `pattern-not` tag to specify that the rule should not match when `KeyGenerator.getInstance(\\\"AES\\\")` is called. This will ensure that only `Cipher.getInstance(\\\"AES\\\")` is flagged.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: KeyGenerator.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":298,\"prompt_tokens\":370,\"total_tokens\":668,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798780133d5ca6d63c085d74f79c83fb40f8c8b47de260\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher.getInstance(\\\"AES\\\")` that the rule is intended to catch. To avoid this false positive, we can add a `pattern-not` to exclude instances where `KeyGenerator.getInstance(\\\"AES\\\")` is used. This ensures that the rule only flags cases where `Cipher.getInstance(\\\"AES\\\")` is called, which is the intended target of the rule.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: KeyGenerator.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979886,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":261,\"prompt_tokens\":371,\"total_tokens\":632,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878026c038e14dcafb30bd771c014e08fe6acc9f7595\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher` class and therefore should not trigger the rule. To exclude this case, we can use the `pattern-not` tag to specify that the rule should not match when `KeyGenerator.getInstance(\\\"AES\\\")` is used. This ensures that the rule only flags instances where `Cipher.getInstance(\\\"AES\\\")` is called without specifying a secure mode.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: javax.crypto.KeyGenerator.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979887,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":261,\"prompt_tokens\":373,\"total_tokens\":634,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798775230a2240b512b1216e229d168cab83c194ab110d\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher` class and therefore should not trigger the rule. To exclude this case, we can add a `pattern-not` clause to ensure that the rule only matches instances where `Cipher.getInstance(\\\"AES\\\")` is called, not `KeyGenerator.getInstance(\\\"AES\\\")`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: KeyGenerator.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979887,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":242,\"prompt_tokens\":375,\"total_tokens\":617,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987824794de96d1828801c6644b74af0176abc6bbed07\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher.getInstance(\\\"AES\\\")` that the rule is intended to catch. To exclude this false positive, we can add a `pattern-not` to ensure that the rule does not trigger on `KeyGenerator.getInstance(\\\"AES\\\")`. This will help the rule correctly classify the example as a false positive.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: KeyGenerator.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979886,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":247,\"prompt_tokens\":376,\"total_tokens\":623,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "use-of-default-aes", "rule": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  pattern: $CIPHER.getInstance(\"AES\")\n  severity: WARNING\n", "failed_tests": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}"], "failed_type": "fp", "testsuite_a": "class AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "testsuite_b": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}\n", "ground_truth": "rules:\n  - id: use-of-default-aes\n    pattern-either:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax;\n                  ...\n          - pattern-either:\n              - pattern: javax.crypto.Cipher.getInstance(\"AES\")\n              - pattern: (javax.crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto;\n                  ...\n          - pattern-either:\n              - pattern: crypto.Cipher.getInstance(\"AES\")\n              - pattern: (crypto.Cipher $CIPHER).getInstance(\"AES\")\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  import javax.crypto.*;\n                  ...\n              - pattern-inside: |\n                  import javax.crypto.Cipher;\n                  ...\n          - pattern-either:\n              - pattern: Cipher.getInstance(\"AES\")\n              - pattern: (Cipher $CIPHER).getInstance(\"AES\")\n    metadata:\n      cwe:\n        - \"CWE-327: Use of a Broken or Risky Cryptographic Algorithm\"\n      owasp:\n        - A03:2017 - Sensitive Data Exposure\n        - A02:2021 - Cryptographic Failures\n      category: security\n      technology:\n        - java\n      references:\n        - https://owasp.org/Top10/A02_2021-Cryptographic_Failures\n        - https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html\n      subcategory:\n        - vuln\n      likelihood: MEDIUM\n      impact: MEDIUM\n      confidence: HIGH\n    message: >-\n      Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't \n      provide message confidentiality and is not semantically secure so should not be used.\n      Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions\n      for more information.\n    severity: WARNING\n    languages:\n      - java\n", "rule_path": "extend_dataset/f84a5d83/before/use-of-default-aes.yaml", "test_path": "extend_dataset/f84a5d83/after/use-of-default-aes.java", "category": "historical", "splited_testsuite_b": ["import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ruleid: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ruleid: use-of-default-aes\n    useCipher(javax.crypto.Cipher.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}", "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void ok() {\n    // ok: use-of-default-aes\n    javax.crypto.KeyGenerator.getInstance(\"AES/CBC/PKCS7PADDING\");\n  }\n}"], "actual": [true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: use-of-default-aes\n  languages:\n  - java\n  message: '\n\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\n\n    '\n  patterns:\n  - pattern: $CIPHER.getInstance(\"AES\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import javax;\n\nimport javax.*;\n// import javax.crypto;\n\nimport javax.crypto.*;\n// import javax.crypto.Cipher;\n\nclass AES{\n  public void useofAES2() {\n    // ok: use-of-default-aes\n    useCipher(javax.crypto.KeyGenerator.getInstance(\"AES\"));\n  }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878211bda357bc18307428e648adfc774a7b98bf790e\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `KeyGenerator.getInstance(\\\"AES\\\")`, which is not related to the `Cipher.getInstance(\\\"AES\\\")` pattern that the rule is intended to catch. To avoid this false positive, we can add a `pattern-not` clause to exclude instances where `KeyGenerator.getInstance(\\\"AES\\\")` is used. This ensures that the rule only flags cases where `Cipher.getInstance(\\\"AES\\\")` is used without specifying a secure mode.\\n\\nThe `pattern-not` clause will help in distinguishing between the use of `Cipher` and `KeyGenerator`, thus correctly classifying the false positive example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: use-of-default-aes\\n  languages:\\n  - java\\n  message: '\\n\\n    Use of AES detected with no settings; defaulting to ECB mode. ECB lacks message\\n    confidentiality and is not secure. Use a stronger cipher: Cipher.getInstance(\\\"AES/CBC/PKCS7PADDING\\\").\\n    For more details, visit https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions.\\n\\n    '\\n  patterns:\\n  - pattern: $CIPHER.getInstance(\\\"AES\\\")\\n  - pattern-not: $KEYGEN.getInstance(\\\"AES\\\")\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":292,\"prompt_tokens\":379,\"total_tokens\":671,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "saxparserfactory", "rule": "rules:\n- id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n  languages:\n  - java\n  message: Instantiating SAXParserFactory without disabling entity processing via\n    setFeature functions.\n  patterns:\n  - pattern-either:\n    - pattern: 'SAXParserFactory $SPF =  ... ;\n\n        ...\n\n        SAXParser $SAXPARSER = $SPF.newSAXParser();\n\n        ...\n\n        $SAXPARSER.parse(...);\n\n        '\n    - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n    - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XXX.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\"\\\n      , true);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-general-entities\\\"\\\n      , false);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-parameter-entities\\\"\\\n      , false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: 'SAXParserFactory $SPF = ... ;\n\n      ...\n\n      $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n      '\n  severity: ERROR\n", "failed_tests": ["```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```"], "failed_type": "fp", "testsuite_a": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/xmlReader/vuln\")\n    public String xmlReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n            return \"xmlReader xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/xmlReader/sec\", method = RequestMethod.POST)\n    public String xmlReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n\n            // fix code start\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            //fix code end\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"xmlReader xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/vuln\", method = RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXBuilder builder = new SAXBuilder();\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  // cause xxe\n            return \"SAXBuilder xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/sec\", method = RequestMethod.POST)\n    public String SAXBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder = new SAXBuilder();\n            builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXBuilder xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/vuln\", method = RequestMethod.POST)\n    public String SAXReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXReader reader = new SAXReader();\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body))); // cause xxe\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXReader xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/sec\", method = RequestMethod.POST)\n    public String SAXReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXReader reader = new SAXReader();\n            reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body)));\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXReader xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/Digester/vuln\", method = RequestMethod.POST)\n    public String DigesterVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            Digester digester = new Digester();\n            digester.parse(new StringReader(body));  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"Digester xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/Digester/sec\", method = RequestMethod.POST)\n    public String DigesterSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            Digester digester = new Digester();\n            digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            digester.parse(new StringReader(body));  // parse xml\n\n            return \"Digester xxe security code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // \u6709\u56de\u663e\n    @RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln01(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // \u904d\u5386xml\u8282\u70b9name\u548cvalue\n            StringBuilder buf = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent()));\n                }\n            }\n            sr.close();\n            return buf.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // \u6709\u56de\u663e\n    @RequestMapping(value = \"/DocumentBuilder/vuln02\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln02(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // \u904d\u5386xml\u8282\u70b9name\u548cvalue\n            StringBuilder result = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    // \u6b63\u5e38\u89e3\u6790XML\uff0c\u9700\u8981\u5224\u65ad\u662f\u5426\u662fELEMENT_NODE\u7c7b\u578b\u3002\u5426\u5219\u4f1a\u51fa\u73b0\u591a\u4f59\u7684\u7684\u8282\u70b9\u3002\n                    if (child.item(j).getNodeType() == Node.ELEMENT_NODE) {\n                        result.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getFirstChild()));\n                    }\n                }\n            }\n            sr.close();\n            return result.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/Sec\", method = RequestMethod.POST)\n    public String DocumentBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            db.parse(is);  // parse xml\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/vuln\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setXIncludeAware(true);   // \u652f\u6301XInclude\n            dbf.setNamespaceAware(true);  // \u652f\u6301XInclude\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n            return \"DocumentBuilder xinclude xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/sec\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n            dbf.setXIncludeAware(true);   // \u652f\u6301XInclude\n            dbf.setNamespaceAware(true);  // \u652f\u6301XInclude\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xinclude xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/vuln\")\n    public String XMLReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLReader xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/sec\")\n    public String XMLReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"XMLReader xxe security code\";\n    }\n\n\n    /**\n     * \u4fee\u590d\u8be5\u6f0f\u6d1e\u53ea\u9700\u5347\u7ea7dom4j\u52302.1.1\u53ca\u4ee5\u4e0a\uff0c\u8be5\u7248\u672c\u53ca\u4ee5\u4e0a\u7981\u7528\u4e86ENTITY\uff1b\n     * \u4e0d\u5e26ENTITY\u7684PoC\u4e0d\u80fd\u5229\u7528\uff0c\u6240\u4ee5\u7981\u7528ENTITY\u5373\u53ef\u5b8c\u6210\u4fee\u590d\u3002\n     */\n    @PostMapping(\"/DocumentHelper/vuln\")\n    public String DocumentHelper(HttpServletRequest req) {\n        try {\n            String body = WebUtils.getRequestBody(req);\n            DocumentHelper.parseText(body); // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"DocumentHelper xxe vuln code\";\n    }\n\n\n    private static void response(NodeList rootNodeList){\n        for (int i = 0; i < rootNodeList.getLength(); i++) {\n            Node rootNode = rootNodeList.item(i);\n            NodeList xxe = rootNode.getChildNodes();\n            for (int j = 0; j < xxe.getLength(); j++) {\n                Node xxeNode = xxe.item(j);\n                // \u6d4b\u8bd5\u4e0d\u80fdblind xxe\uff0c\u6240\u4ee5\u5f3a\u884c\u52a0\u4e86\u4e00\u4e2a\u56de\u663e\n                logger.info(\"xxeNode: \" + xxeNode.getNodeValue());\n            }\n\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "testsuite_b": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "ground_truth": "rules:\n  - id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n    message: >-\n      SAXParserFactory being instantiated without calling the setFeature functions that are generally used for disabling entity\n      processing\n    metadata:\n      cwe: \"CWE-611: Improper Restriction of XML External Entity Reference\"\n      owasp: \"A4: XML External Entities (XXE)\"\n      source-rule-url: https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n      category: security\n    severity: ERROR\n    patterns:\n      # Reference : https://www.programcreek.com/java-api-examples/?api=javax.xml.parsers.SAXParserFactory\n      - pattern-either:\n          - pattern: |\n              SAXParserFactory $SPF =  ... ;\n              ...\n              SAXParser $SAXPARSER = $SPF.newSAXParser();\n              ...\n              $SAXPARSER.parse(...);\n          - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n          - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            ...\n          }\n      - pattern-not-inside: |\n          SAXParserFactory $SPF = ... ;\n          ...\n          $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    languages:\n      - java\n", "rule_path": "extend_dataset/0eed6610/before/saxparserfactory.yaml", "test_path": "extend_dataset/0eed6610/after/saxparserfactory.java", "category": "historical", "splited_testsuite_b": ["```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```", "```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```"], "actual": [true, true], "expected": [true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n  languages:\n  - java\n  message: Instantiating SAXParserFactory without disabling entity processing via\n    setFeature functions.\n  patterns:\n  - pattern-either:\n    - pattern: 'SAXParserFactory $SPF =  ... ;\n\n        ...\n\n        SAXParser $SAXPARSER = $SPF.newSAXParser();\n\n        ...\n\n        $SAXPARSER.parse(...);\n\n        '\n    - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n    - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XXX.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\"\\\n      , true);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-general-entities\\\"\\\n      , false);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-parameter-entities\\\"\\\n      , false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: 'SAXParserFactory $SPF = ... ;\n\n      ...\n\n      $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n      '\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n  languages:\n  - java\n  message: Instantiating SAXParserFactory without disabling entity processing via\n    setFeature functions.\n  patterns:\n  - pattern-either:\n    - pattern: 'SAXParserFactory $SPF =  ... ;\n\n        ...\n\n        SAXParser $SAXPARSER = $SPF.newSAXParser();\n\n        ...\n\n        $SAXPARSER.parse(...);\n\n        '\n    - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\n    - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XXX.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\"\\\n      , true);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-general-entities\\\"\\\n      , false);\\n  $XXX.setFeature(\\\"http://xml.org/sax/features/external-parameter-entities\\\"\\\n      , false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: 'SAXParserFactory $SPF = ... ;\n\n      ...\n\n      $SPF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n      $SPF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n      '\n  severity: ERROR\n", "incorrect": "```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.parsers.SAXParserFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```", "type": "fp"}, "response": "{\"id\":\"0217399798778525361762ce9a5abd1d1afeaebe5fcfcabd2e971\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `SAXParserFactory` instance that is correctly configured with the `setFeature` method to disable external entities, which should not trigger the rule. However, the current rule does not account for cases where the `setFeature` method is called immediately after the `SAXParserFactory` instantiation. To fix this, we need to add a `pattern-not-inside` clause that matches the scenario where the `setFeature` method is called right after the `SAXParserFactory` instantiation.\\n\\nThe new `pattern-not-inside` clause will ensure that the rule does not flag cases where the `SAXParserFactory` is properly configured with the `setFeature` method.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: owasp.java.xxe.javax.xml.parsers.SAXParserFactory\\n  languages:\\n  - java\\n  message: Instantiating SAXParserFactory without disabling entity processing via\\n    setFeature functions.\\n  patterns:\\n  - pattern-either:\\n    - pattern: 'SAXParserFactory $SPF =  ... ;\\n\\n        ...\\n\\n        SAXParser $SAXPARSER = $SPF.newSAXParser();\\n\\n        ...\\n\\n        $SAXPARSER.parse(...);\\n\\n        '\\n    - pattern: SAXParserFactory $SPF = SAXParserFactory.newInstance();\\n    - pattern: SAXParser $SAXPARSER = SAXParserFactory.newInstance().newSAXParser();\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(...) {\\\\n  ...\\\\n  $XXX.setFeature(\\\\\\\"http://apache.org/xml/features/disallow-doctype-decl\\\\\\\"\\\\\\n      , true);\\\\n  $XXX.setFeature(\\\\\\\"http://xml.org/sax/features/external-general-entities\\\\\\\"\\\\\\n      , false);\\\\n  $XXX.setFeature(\\\\\\\"http://xml.org/sax/features/external-parameter-entities\\\\\\\"\\\\\\n      , false);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not-inside: 'SAXParserFactory $SPF = ... ;\\n\\n      ...\\n\\n      $SPF.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\", true);\\n\\n      $SPF.setFeature(\\\"http://xml.org/sax/features/external-general-entities\\\", false);\\n\\n      $SPF.setFeature(\\\"http://xml.org/sax/features/external-parameter-entities\\\", false);\\n\\n      '\\n  - pattern-not-inside: 'SAXParserFactory $SPF = SAXParserFactory.newInstance();\\n      $SPF.setFeature(\\\"http://apache.org/xml/features/disallow-doctype-decl\\\", true);\\n      ...'\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979899,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":596,\"prompt_tokens\":1014,\"total_tokens\":1610,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "incorrect": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979877942d415e58c096a7f34955926826fc72fa972656f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a call to `response.setHeader(\\\"Set-Cookie\\\", null);`, which sets the `Set-Cookie` header to `null`. This should not trigger the rule because the `SameSite` attribute is irrelevant when the cookie value is `null`. To exclude this case, we can add a `pattern-not` to match calls where the second argument to `setHeader` is `null`. This will ensure that such cases are not flagged by the rule.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: cookie-missing-samesite\\n  languages:\\n  - java\\n  message: Detected cookie missing SameSite attribute.\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\\\\n      \\\\ {\\\\n  ...\\\\n  $RESP.setHeader(\\\\\\\"Set-Cookie\\\\\\\", \\\\\\\"=~/.*SameSite=.*/\\\\\\\");\\\\n  ...\\\\n\\\\\\n      }\\\\n\\\"\\n  - pattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n  - pattern-either:\\n    - pattern: $RESP.addCookie(...);\\n    - pattern: $RESP.setHeader(\\\"Set-Cookie\\\", ...);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":284,\"prompt_tokens\":394,\"total_tokens\":678,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "incorrect": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878014b8278729ff36ef4d4e2cc093528a7294d81b89\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `setHeader` call where the value is `null`. The current rule flags any `setHeader` call with \\\"Set-Cookie\\\" as a potential issue, but it should not flag cases where the header value is `null` because no cookie is actually being set. To address this, we can add a `pattern-not` to exclude cases where the `setHeader` value is `null`. This will ensure that the rule only flags instances where a cookie is being set without the `SameSite` attribute.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: cookie-missing-samesite\\n  languages:\\n  - java\\n  message: Detected cookie missing SameSite attribute.\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\\\\n      \\\\ {\\\\n  ...\\\\n  $RESP.setHeader(\\\\\\\"Set-Cookie\\\\\\\", \\\\\\\"=~/.*SameSite=.*/\\\\\\\");\\\\n  ...\\\\n\\\\\\n      }\\\\n\\\"\\n  - pattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n  - pattern-either:\\n    - pattern: $RESP.addCookie(...);\\n    - pattern: $RESP.setHeader(\\\"Set-Cookie\\\", ...);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":296,\"prompt_tokens\":394,\"total_tokens\":690,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "incorrect": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979877475d415e58c096a7f34955926826fc72fa9b00f4c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves setting the \\\"Set-Cookie\\\" header to `null`, which does not represent a cookie missing the SameSite attribute. To exclude such cases, we can add a `pattern-not` to ensure that the rule does not trigger when the \\\"Set-Cookie\\\" header is set to `null`. This will prevent the rule from flagging cases where the header is explicitly set to `null`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: cookie-missing-samesite\\n  languages:\\n  - java\\n  message: Detected cookie missing SameSite attribute.\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\\\\n      \\\\ {\\\\n  ...\\\\n  $RESP.setHeader(\\\\\\\"Set-Cookie\\\\\\\", \\\\\\\"=~/.*SameSite=.*/\\\\\\\");\\\\n  ...\\\\n\\\\\\n      }\\\\n\\\"\\n  - pattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n  - pattern-either:\\n    - pattern: $RESP.addCookie(...);\\n    - pattern: $RESP.setHeader(\\\"Set-Cookie\\\", ...);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979886,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":269,\"prompt_tokens\":394,\"total_tokens\":663,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "incorrect": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987783864e07ef8922a772e1a8aa6b8c3ca8d6e418bd1\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `setHeader` call where the \\\"Set-Cookie\\\" header is set to `null`. This should not trigger the rule because setting the header to `null` effectively removes it, and the rule is intended to flag cases where the \\\"Set-Cookie\\\" header is set without the \\\"SameSite\\\" attribute. To exclude this case, we can add a `pattern-not` that matches `setHeader` calls where the value is `null`.\\n\\nThe new pattern should be:\\n```yaml\\npattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n```\\nThis will ensure that the rule does not flag cases where the \\\"Set-Cookie\\\" header is explicitly set to `null`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: cookie-missing-samesite\\n  languages:\\n  - java\\n  message: Detected cookie missing SameSite attribute.\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\\\\n      \\\\ {\\\\n  ...\\\\n  $RESP.setHeader(\\\\\\\"Set-Cookie\\\\\\\", \\\\\\\"=~/.*SameSite=.*/\\\\\\\");\\\\n  ...\\\\n\\\\\\n      }\\\\n\\\"\\n  - pattern-either:\\n    - pattern: $RESP.addCookie(...);\\n    - pattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n    - pattern: $RESP.setHeader(\\\"Set-Cookie\\\", ...);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":333,\"prompt_tokens\":394,\"total_tokens\":727,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "cookie-missing-samesite", "rule": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  severity: WARNING\n", "failed_tests": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "failed_type": "fp", "testsuite_a": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}\n", "testsuite_b": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n", "ground_truth": "rules:\n- id: cookie-missing-samesite\n  metadata:\n    cwe:\n    - 'CWE-352: Cross-Site Request Forgery (CSRF)'\n    owasp:\n    - A01:2021 - Broken Access Control\n    asvs:\n      section: 'V3: Session Management Verification Requirements'\n      control_id: 3.4.3 Missing Cookie Attribute\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management\n      version: '4'\n    references:\n    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: LOW\n    confidence: LOW\n  message: >-\n    Detected cookie without the SameSite attribute.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not-inside: |\n      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {\n        ...\n        $RESP.setHeader(\"Set-Cookie\", \"=~/.*SameSite=.*/\");\n        ...\n      }\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n  - pattern-not: $RESP.setHeader(\"Set-Cookie\", null);\n", "rule_path": "extend_dataset/54c53a25/before/cookie-missing-samesite.yaml", "test_path": "extend_dataset/54c53a25/after/cookie-missing-samesite.java", "category": "historical", "splited_testsuite_b": ["@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie1\", method = \"GET\")\n    public void setCookie(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; SameSite=strict\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie2\", method = \"GET\")\n    public void setSecureCookie(@RequestParam String value, HttpServletResponse response) {\n        // ruleid:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly;\");\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie3\", method = \"GET\")\n    public void setSecureHttponlyCookie(@RequestParam String value, HttpServletResponse response) {\n        Cookie cookie = new Cookie(\"cookie\", value);\n        cookie.setSecure(true);\n        cookie.setHttpOnly(true);\n        // ruleid:cookie-missing-samesite\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", \"key=value; HttpOnly; Secure; SameSite=strict\");\n        response.addCookie(cookie);\n    }\n}", "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}"], "actual": [false, true, true, false, true], "expected": [false, true, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - patterns:\n      - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\n@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: cookie-missing-samesite\n  languages:\n  - java\n  message: Detected cookie missing SameSite attribute.\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\n      \\ {\\n  ...\\n  $RESP.setHeader(\\\"Set-Cookie\\\", \\\"=~/.*SameSite=.*/\\\");\\n  ...\\n\\\n      }\\n\"\n  - pattern-either:\n    - pattern: $RESP.addCookie(...);\n    - patterns:\n      - pattern: $RESP.setHeader(\"Set-Cookie\", ...);\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "@Controller\npublic class CookieController {\n\n    @RequestMapping(value = \"/cookie4\", method = \"GET\")\n    public void setEverything(@RequestParam String value, HttpServletResponse response) {\n        // ok:cookie-missing-samesite\n        response.setHeader(\"Set-Cookie\", null);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979877688945ada8e478a29a2419a74b62ea11110ccf482\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves setting the \\\"Set-Cookie\\\" header to `null`. The current rule flags any `setHeader(\\\"Set-Cookie\\\", ...)` call as a potential issue, but setting it to `null` should not be considered a missing SameSite attribute since the header is effectively being removed or not set. To prevent this false positive, we need to add a `pattern-not` that excludes cases where the \\\"Set-Cookie\\\" header is set to `null`.\\n\\nBy adding a `pattern-not` that matches `response.setHeader(\\\"Set-Cookie\\\", null);`, we can ensure that such cases are not flagged by the rule.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: cookie-missing-samesite\\n  languages:\\n  - java\\n  message: Detected cookie missing SameSite attribute.\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...)\\\\\\n      \\\\ {\\\\n  ...\\\\n  $RESP.setHeader(\\\\\\\"Set-Cookie\\\\\\\", \\\\\\\"=~/.*SameSite=.*/\\\\\\\");\\\\n  ...\\\\n\\\\\\n      }\\\\n\\\"\\n  - pattern-either:\\n    - pattern: $RESP.addCookie(...);\\n    - patterns:\\n      - pattern: $RESP.setHeader(\\\"Set-Cookie\\\", ...);\\n      - pattern-not: $RESP.setHeader(\\\"Set-Cookie\\\", null);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":321,\"prompt_tokens\":398,\"total_tokens\":719,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n", "incorrect": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987742747e8c3e2b4aa2db09eb5532cedd62c3655a484\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves an `if` statement that checks the result of a method call (`moveToChild(curs, index, false, false)`). The current rule incorrectly flags this as a hardcoded conditional because it matches the `false` literal within the method call. To avoid this false positive, we need to ensure that the rule does not match `false` when it is used as an argument in a method call. We can achieve this by adding a `pattern-not-inside` pattern that excludes method calls containing `false`.\\n\\nThe `pattern-not-inside` pattern will prevent the rule from matching `false` when it appears inside a method call, thus correctly classifying the example as not a hardcoded conditional.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: hardcoded-conditional\\n  languages:\\n  - java\\n  message: '\\n    Unnecessary if statement; behavior remains constant.\\n    '\\n  pattern-either:\\n  - pattern: if (<... true ...>) { ... }\\n  - patterns:\\n    - pattern: if (<... false ...>) { ... }\\n    - pattern-not-inside: if ($FUNC($..., false, $...)) { ... }\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":273,\"prompt_tokens\":321,\"total_tokens\":594,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n", "incorrect": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878196d415e58c096a7f34955926826fc72fa96d2517\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves an `if` statement where the condition is a method call `moveToChild(curs, index, false, false)`, rather than a hardcoded `true` or `false`. To prevent the rule from flagging such cases, we need to add a `pattern-not-inside` pattern that excludes `if` statements where the condition is a method call. This ensures that only `if` statements with hardcoded `true` or `false` conditions are flagged.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: hardcoded-conditional\\n  languages:\\n  - java\\n  message: '\\n\\n    Unnecessary if statement; behavior remains constant.\\n\\n    '\\n  pattern-either:\\n  - pattern: if (<... true ...>) { ... }\\n  - patterns:\\n    - pattern: if (<... false ...>) { ... }\\n    - pattern-not-inside: if ($METHOD(...)) { ... }\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979887,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":222,\"prompt_tokens\":321,\"total_tokens\":543,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "incorrect": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987778394a08c2b5b77fae6b1b30d66cf049efa467df0\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves an `if` statement where the condition is a method call `moveToChild(curs, index, false, false)` rather than a hardcoded `true` or `false` value. The current rule incorrectly flags this as an error because it matches the `false` literal within the method call. To prevent this, we can add a `pattern-not-inside` clause to exclude cases where `false` or `true` appears as arguments within a method call. This will ensure that only `if` statements with hardcoded `true` or `false` as the condition are flagged.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: hardcoded-conditional\\n  languages:\\n  - java\\n  message: '\\n\\n    Unnecessary if statement; behavior remains constant.\\n\\n    '\\n  pattern-either:\\n  - pattern: if (<... true ...>) { ... }\\n  - pattern-not-inside: if ($FUNC($..., <... true ...>, $...)) { ... }\\n  - pattern: if (<... false ...>) { ... }\\n  - pattern-not-inside: if ($FUNC($..., <... false ...>, $...)) { ... }\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979894,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":276,\"prompt_tokens\":317,\"total_tokens\":593,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - patterns:\n    - pattern: if (<... false ...>) { ... }\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n", "incorrect": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798781442b0555455acbf1dd3051b763fdd9baee8897a1\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves an `if` statement where the condition is a function call `moveToChild(curs, index, false, false)`, which returns a boolean value. The current rule incorrectly flags this as a hardcoded conditional because it matches the pattern `if (<... false ...>) { ... }`. To avoid this false positive, we need to add a `pattern-not-inside` clause that excludes `if` statements where the condition is a function call. This way, the rule will only flag `if` statements with hardcoded `true` or `false` literals directly in the condition.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: hardcoded-conditional\\n  languages:\\n  - java\\n  message: '\\n    Unnecessary if statement; behavior remains constant.\\n    '\\n  pattern-either:\\n  - pattern: if (<... true ...>) { ... }\\n  - patterns:\\n    - pattern: if (<... false ...>) { ... }\\n    - pattern-not-inside: if ($FUNC(...)) { ... }\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979886,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":247,\"prompt_tokens\":321,\"total_tokens\":568,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "hardcoded-conditional", "rule": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "failed_tests": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n    }\n}\n", "testsuite_b": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n\n        // the dataflow constant-propagation now kicks in! this is true!\n        // ruleid:hardcoded-conditional\n        if (myBoolean) {\n\n        }\n        // to prevent constant propagation to assumes\n        // myBoolean is true below\n        myBoolean = arg;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n\n    }\n}\n", "ground_truth": "rules:\n- id: hardcoded-conditional\n  patterns:\n  - pattern-either:\n    - pattern: if (true) { ... }\n    - pattern: if (false) { ... }\n    - pattern: if ($VAR = true) { ... }\n    - pattern: if ($VAR = false) { ... }\n    - pattern: if ($EXPR && false) { ... }\n    - pattern: if (false && $EXPR) { ... }\n    - pattern: if ($EXPR || true) { ... }\n    - pattern: if (true || $EXPR) { ... }\n  message: This if statement will always have the same behavior and is therefore unnecessary.\n  languages: [java]\n  severity: ERROR\n  metadata:\n    category: correctness\n    technology:\n    - java\n", "rule_path": "extend_dataset/46347b7f/before/hardcoded-conditional.yaml", "test_path": "extend_dataset/46347b7f/after/hardcoded-conditional.java", "category": "historical", "splited_testsuite_b": ["class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (myBoolean = true) {\n            continue;\n        }\n        // note that with new constant propagation, myBoolean is assumed\n        // to true below\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ruleid:hardcoded-conditional\n        if (true && false) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean == myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (myBoolean != myBoolean) {\n            continue;\n        }\n    }\n}", "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}"], "actual": [true, true, true, false, false, true], "expected": [true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\nclass Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: hardcoded-conditional\n  languages:\n  - java\n  message: '\n\n    Unnecessary if statement; behavior remains constant.\n\n    '\n  pattern-either:\n  - pattern: if (<... true ...>) { ... }\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern: if (<... false ...>) { ... }\n  severity: ERROR\n", "incorrect": "class Bar {\n    void main(boolean arg) {\n        boolean myBoolean;\n\n        // ok:hardcoded-conditional\n        if (moveToChild(curs, index, false, false))\n        {\n            removeToken(curs);\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987824186d8bc314f8bdcfb1f6fce462bf02e4a38b8ec\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a method call `moveToChild(curs, index, false, false)` within the `if` condition. The current rule incorrectly flags this as a hardcoded conditional because it sees the `false` values inside the method call. To avoid this, we can add a `pattern-not-inside` clause to exclude `if` statements that contain method calls with `false` or `true` as arguments. This way, the rule will only flag `if` statements with direct hardcoded `true` or `false` conditions, not those that involve method calls with `true` or `false` arguments.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: hardcoded-conditional\\n  languages:\\n  - java\\n  message: '\\n    Unnecessary if statement; behavior remains constant.\\n    '\\n  pattern-either:\\n  - pattern: if (<... true ...>) { ... }\\n  - pattern-not-inside: if ($METHOD(..., true, ...)) { ... }\\n  - pattern-not-inside: if ($METHOD(..., false, ...)) { ... }\\n  - pattern: if (<... false ...>) { ... }\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979888,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":269,\"prompt_tokens\":317,\"total_tokens\":586,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979877511320f9aadc50dbf6687c3b1e9f9e54ac63397b3\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves the use of `out.format(...)` to write to the HTTP response, which is not currently covered by the existing patterns in the Semgrep rule. To correctly classify this example, we need to add a new pattern that matches the `PrintWriter.format(...)` method call. This will ensure that any direct writing to the response using `format` is detected.\\n\\nThe new pattern should be added to the `pattern-either` section to match `PrintWriter.format(...)` calls.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: no-direct-response-writer\\n  languages:\\n  - java\\n  message: Detected direct write to the HTTP response, bypassing view/template environments\\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\\n    escaping.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\\n        }\\n\\n        '\\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\\n\\n        ...\\n\\n        '\\n  - pattern-either:\\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).format(...)\\n\\n        '\\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\\n\\n        '\\n  - pattern-not: $WRITER.$WRITE(\\\"...\\\", ...)\\n  - pattern-not: $WRITER.flush(...)\\n  - pattern-not: $WRITER.close(...)\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":425,\"prompt_tokens\":1090,\"total_tokens\":1515,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878196ea6e22211971fe3d61d4d52464fb6420a50ec3\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves the use of `out.format(...)` to write to the HTTP response, which is not currently covered by the existing patterns in the Semgrep rule. The rule should be updated to detect this method call on a `PrintWriter` object, as it can also bypass view/template environments and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n\\nTo address this, we need to add a new pattern that matches the `$WRITER.format(...)` method call, where `$WRITER` is a `PrintWriter` object. This will ensure that the rule correctly identifies and flags such instances as potential security risks.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: no-direct-response-writer\\n  languages:\\n  - java\\n  message: Detected direct write to the HTTP response, bypassing view/template environments\\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\\n    escaping.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\\n        }\\n\\n        '\\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\\n\\n        ...\\n\\n        '\\n  - pattern-either:\\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).format(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\\n\\n        '\\n  - pattern-not: $WRITER.$WRITE(\\\"...\\\", ...)\\n  - pattern-not: $WRITER.flush(...)\\n  - pattern-not: $WRITER.close(...)\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":454,\"prompt_tokens\":1090,\"total_tokens\":1544,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782988b7af1322b4712086cec2445c998af098abb97\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves the use of `out.format(...)` to write to the HTTP response, which is not currently captured by the existing patterns in the Semgrep rule. The rule needs to be updated to include a pattern that matches this method call. Specifically, we need to add a pattern that captures `PrintWriter.format(...)` or `PrintWriter.printf(...)` calls, as these methods can also be used to write to the response directly, bypassing view/template environments and HTML escaping.\\n\\nThe new pattern should be added to the list of patterns in the `pattern-either` block to ensure that such cases are detected.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: no-direct-response-writer\\n  languages:\\n  - java\\n  message: Detected direct write to the HTTP response, bypassing view/template environments\\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\\n    escaping.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\\n        }\\n\\n        '\\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\\n\\n        ...\\n\\n        '\\n  - pattern-either:\\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).format(...)\\n\\n        '\\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\\n\\n        '\\n  - pattern-not: $WRITER.$WRITE(\\\"...\\\", ...)\\n  - pattern-not: $WRITER.flush(...)\\n  - pattern-not: $WRITER.close(...)\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979897,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":451,\"prompt_tokens\":1090,\"total_tokens\":1541,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878194f942e386849eac873461595dafd0b1359e30ef\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves the use of `out.format(...)` to write to the HTTP response, which is not currently covered by the existing patterns in the rule. To correctly classify this example, we need to add a new pattern that matches the `out.format(...)` method call. This will ensure that the rule catches instances where `PrintWriter.format(...)` is used to write directly to the response, which could lead to XSS vulnerabilities if the content is not properly escaped.\\n\\nThe new pattern should be added under the `pattern-either` section to match the `PrintWriter.format(...)` method call.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: no-direct-response-writer\\n  languages:\\n  - java\\n  message: Detected direct write to the HTTP response, bypassing view/template environments\\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\\n    escaping.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\\n        }\\n\\n        '\\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\\n\\n        ...\\n\\n        '\\n  - pattern-either:\\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).format(...)\\n\\n        '\\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\\n\\n        '\\n  - pattern-not: $WRITER.$WRITE(\\\"...\\\", ...)\\n  - pattern-not: $WRITER.flush(...)\\n  - pattern-not: $WRITER.close(...)\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":445,\"prompt_tokens\":1090,\"total_tokens\":1535,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-direct-response-writer", "rule": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "failed_type": "fp", "testsuite_a": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        PrintWriter writer = response.getWriter();\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        writer.printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            PrintWriter writer = response.getWriter();\n            // ruleid: no-direct-response-writer\n            writer.println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        PrintWriter writer = response.getWriter();\n        writer.println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n\n    ///\n    // random tests from https://dev.massive.ret2.co/triager/triage/1193\n    ///\n    private static void writeAndFlush(\n        final ByteBuffer buffer, final OutputStream outputStream) throws IOException {\n\n        if (buffer.hasArray()) {\n            // ok: no-direct-response-writer\n            outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\n        }\n    }\n\n    private void saveResourceAsFile(String resourceName, File file) throws IOException {\n        InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName);\n        if ( input==null ) {\n            System.err.println(\"Can't find \" + resourceName + \" as resource\");\n            throw new IOException(\"Missing resource:\" + resourceName);\n        }\n        OutputStream output = new FileOutputStream(file.getAbsolutePath());\n        while(input.available()>0) {\n            // ok: no-direct-response-writer\n            output.write(input.read());\n        }\n        output.close();\n        input.close();\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Cache-Control\",\"no-cache\");\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json\");\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n\n    // test pattern where HttpServletResponse is retrieved via a method rather than parameters\n    public void commence2(Something something) throws IOException, ServletException {\n        HttpServletResponse response = something.getResponse();\n        // ruleid: no-direct-response-writer\n        response.getWriter().println(\"blarg\" + something.getData());\n        // ok: no-direct-response-writer\n        response.getWriter().flush();\n    }\n}\n", "testsuite_b": "/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest( request );\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n\n        String bar = doSomething(request, param);\n\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte)'?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\n\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\"\n);\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            md.update(input);\n\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(\n                    new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir),\"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget,true); //the true will append the new data\n                fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\n\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\"\n);\n\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\n\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\"\n);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map94322 = new java.util.HashMap<String,Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\"); // put some stuff in the collection\n        map94322.put(\"keyB-94322\", param); // put it in a collection\n        map94322.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map94322.get(\"keyB-94322\"); // get it back out\n        bar = (String)map94322.get(\"keyA-94322\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}\n\n@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}\n\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n\n", "ground_truth": "rules:\n  - id: no-direct-response-writer\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern: (HttpServletRequest $REQ)\n    pattern-sinks:\n    - patterns:\n      - pattern-either:\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n          - pattern: |\n              (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n          - pattern: |\n              (java.io.PrintWriter $WRITER).$WRITE(...)\n          - pattern: |\n              (javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n          - pattern: |\n              (java.io.OutputStream $WRITER).$WRITE(...)\n    message: >-\n      Detected a request with potential user-input going into a OutputStream or Writer object. \n      This bypasses any view or template environments, including HTML escaping, which may\n      expose this application to cross-site scripting (XSS) vulnerabilities.\n      Consider using a view technology such as JavaServer Faces (JSFs) which\n      automatically escapes HTML views.\n    metadata:\n      owasp: \"A7: Cross-Site Scripting (XSS)\"\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      references:\n        - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    languages: [java]\n", "rule_path": "extend_dataset/1792d575/before/no-direct-response-writer.yaml", "test_path": "extend_dataset/1792d575/after/no-direct-response-writer.java", "category": "historical", "splited_testsuite_b": ["/**\n* OWASP Benchmark Project v1.2\n*\n* This file is part of the Open Web Application Security Project (OWASP)\n* Benchmark Project. For details, please see\n* <a href=\"https://www.owasp.org/index.php/Benchmark\">https://www.owasp.org/index.php/Benchmark</a>.\n*\n* The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n* of the GNU General Public License as published by the Free Software Foundation, version 2.\n*\n* The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* @author Nick Sanidas <a href=\"https://www.aspectsecurity.com\">Aspect Security</a>\n* @created 2015\n*/\n\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value=\"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String,String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n\n        String bar = doSomething(request, param);\n\nresponse.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = { \"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US,\"Formatted like: %1$s and %2$s.\",obj);\n    }  // end doPost\n\n\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String,Object> map26903 = new java.util.HashMap<String,Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String)map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String)map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        // OK because constant string\n        // ok: no-direct-response-writer\n        response.getWriter().println(\"Hash Test java.security.MessageDigest.getInstance(java.lang.String) executed\\n\");\n    }\n    private static String doSomething(HttpServletRequest request, String param) throws ServletException, IOException {\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map94322 = new java.util.HashMap<String, Object>();\n        map94322.put(\"keyA-94322\", \"a_Value\");\n        map94322.put(\"keyB-94322\", param);\n        map94322.put(\"keyC\", \"another_Value\");\n        bar = (String) map94322.get(\"keyB-94322\");\n        bar = (String) map94322.get(\"keyA-94322\");\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02229\")\npublic class BenchmarkTest02229 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02229\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        // ruleid: no-direct-response-writer\n        response.getWriter().printf(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = \"safe!\";\n        java.util.HashMap<String, Object> map26903 = new java.util.HashMap<String, Object>();\n        map26903.put(\"keyA-26903\", \"a_Value\"); // put some stuff in the collection\n        map26903.put(\"keyB-26903\", param); // put it in a collection\n        map26903.put(\"keyC\", \"another_Value\"); // put some stuff in the collection\n        bar = (String) map26903.get(\"keyB-26903\"); // get it back out\n        bar = (String) map26903.get(\"keyA-26903\"); // get safe value back out\n\n        return bar;\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            md.update(input);\n            byte[] result = md.digest();\n            java.io.File fileTarget = new java.io.File(new java.io.File(org.owasp.benchmark.helpers.Utils.testfileDir), \"passwordFile.txt\");\n            java.io.FileWriter fw = new java.io.FileWriter(fileTarget, true);\n            fw.write(\"hash_value=\" + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true) + \"\\n\");\n            fw.close();\n            // ruleid: no-direct-response-writer\n            response.getWriter().println(\"Sensitive value '\" + org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(input)) + \"' hashed and stored<br/>\\n\");\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n@WebServlet(value = \"/hash-02/BenchmarkTest02388\")\npublic class BenchmarkTest02388 extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n    private void doPostPart1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        org.owasp.benchmark.helpers.SeparateClassRequest scr = new org.owasp.benchmark.helpers.SeparateClassRequest(request);\n        String param = scr.getTheParameter(\"BenchmarkTest02388\");\n        if (param == null) param = \"\";\n        String bar = doSomething(request, param);\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            byte[] input = { (byte) '?' };\n            Object inputParam = bar;\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    // ok: no-direct-response-writer\n                    response.getWriter().println(\"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\\n\");\n                    return;\n                }\n            }\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"Problem executing hash - TestCase\");\n            throw new ServletException(e);\n        }\n    }\n}", "@WebServlet(value = \"/xss-00/BenchmarkTest00013\")\npublic class BenchmarkTest00013 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // some code\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        String param = \"\";\n        java.util.Enumeration<String> headers = request.getHeaders(\"Referer\");\n\n        if (headers != null && headers.hasMoreElements()) {\n            param = headers.nextElement(); // just grab first element\n        }\n\n        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().\n        param = java.net.URLDecoder.decode(param, \"UTF-8\");\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", \"b\"};\n        // ruleid: no-direct-response-writer\n        response.getWriter().format(java.util.Locale.US, param, obj);\n    }\n}", "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}"], "actual": [true, false, true, true, false, true, false], "expected": [true, false, true, true, false, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: no-direct-response-writer\n  languages:\n  - java\n  message: Detected direct write to the HTTP response, bypassing view/template environments\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\n    escaping.\n  patterns:\n  - pattern-either:\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\n        }\n\n        '\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\n\n        ...\n\n        '\n  - pattern-either:\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n\n        '\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n\n        '\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\n\n        '\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: $WRITER.$WRITE(\"...\", ...)\n  - pattern-not: $WRITER.flush(...)\n  - pattern-not: $WRITER.close(...)\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark Project v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Nick Sanidas\n * @created 2015\n */\npackage org.owasp.benchmark.testcode;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(value = \"/xss-04/BenchmarkTest02221\")\npublic class BenchmarkTest02221 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.util.Map<String, String[]> map = request.getParameterMap();\n        String param = \"\";\n        if (!map.isEmpty()) {\n            String[] values = map.get(\"BenchmarkTest02221\");\n            if (values != null) param = values[0];\n        }\n\n        String bar = doSomething(request, param);\n\n        response.setHeader(\"X-XSS-Protection\", \"0\");\n        Object[] obj = {\"a\", bar};\n        java.io.PrintWriter out = response.getWriter();\n        out.write(\"<!DOCTYPE html>\\n<html>\\n<body>\\n<p>\");\n        // ruleid: no-direct-response-writer\n        out.format(java.util.Locale.US, \"Formatted like: %1$s and %2$s.\", obj);\n        out.write(\"\\n</p>\\n</body>\\n</html>\");\n    } // end doPost\n\n    private static String doSomething(HttpServletRequest request, String param)\n            throws ServletException, IOException {\n\n        String bar = param;\n        if (param != null && param.length() > 1) {\n            StringBuilder sbxyz71523 = new StringBuilder(param);\n            bar = sbxyz71523.replace(param.length() - \"Z\".length(), param.length(), \"Z\").toString();\n        }\n\n        return bar;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878003c6c94518f72b95f9e6f29ca665fbbe2363a1e9\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves the use of `out.format(...)` to write formatted content directly to the HTTP response. The current rule does not catch this because it only looks for direct writes using `$WRITE(...)` methods like `write`, `print`, etc. To correctly classify this example, we need to add a pattern that matches the `format` method when it is called on a `PrintWriter` object obtained from the HTTP response.\\n\\nWe will add a new pattern to the `pattern-either` section to catch the `format` method:\\n```yaml\\n- pattern: '(PrintWriter $WRITER).format(...)'\\n```\\nThis pattern will ensure that the rule catches instances where `format` is used to write directly to the response, thus correctly classifying the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: no-direct-response-writer\\n  languages:\\n  - java\\n  message: Detected direct write to the HTTP response, bypassing view/template environments\\n    and HTML escaping, potentially exposing the application to XSS vulnerabilities.\\n    Consider using a view technology like JavaServer Faces (JSF) for automatic HTML\\n    escaping.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: '$RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ...\\n        }\\n\\n        '\\n    - pattern-inside: 'HttpServletResponse $RESPONSE = ...;\\n\\n        ...\\n\\n        '\\n  - pattern-either:\\n    - pattern: '(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(ServletOutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(OutputStream $WRITER).$WRITE(...)\\n\\n        '\\n    - pattern: '(PrintWriter $WRITER).format(...)\\n\\n        '\\n  - pattern-not: $WRITER.$WRITE(\\\"...\\\", ...)\\n  - pattern-not: $WRITER.flush(...)\\n  - pattern-not: $WRITER.close(...)\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979894,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":484,\"prompt_tokens\":1090,\"total_tokens\":1574,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878054535e4afe6f1c50a8bf173366f3d1df6a9f42c3\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive occurs because the rule is detecting the `execute` method in a context that is unrelated to SQL operations. Specifically, the rule is matching the `execute` method of the `ApiClient` class, which is used for HTTP calls rather than SQL queries. To prevent this false positive, we need to add a pattern that excludes cases where the `execute` method is called on an `ApiClient` object.\\n\\nWe can achieve this by adding a `pattern-not-inside` clause that excludes the context where `execute` is called on an `ApiClient` instance. This will ensure that the rule only flags `execute` methods that are likely to be related to SQL operations.\\n\\nThe pattern should look for the context where `execute` is called on an `ApiClient` object and exclude it from the matches.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern: $W.$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: |\\n            $CLIENT.execute(...)\\n            ...\\n            $CLIENT.run(...)\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":491,\"prompt_tokens\":576,\"total_tokens\":1067,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878240ea6e22211971fe3d61d4d52464fb64203b2993\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive occurs because the rule is matching any method named `execute`, regardless of whether it is related to SQL operations. To fix this, we need to refine the pattern to ensure that the `execute` method is related to SQL operations. We can do this by adding a `pattern-not-inside` clause that excludes cases where the `execute` method is called on objects that are not related to SQL, such as `ApiClient`.\\n\\nBy adding `pattern-not-inside: $W.$SQLFUNC(...)` with a specific exclusion for `ApiClient`, we can prevent the rule from flagging `execute` methods that are not related to SQL operations.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern: $W.$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: $W.$SQLFUNC(...)\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":450,\"prompt_tokens\":576,\"total_tokens\":1026,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878169af3d860f181fcba7f252ea2d6bc1813ab61a73\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive occurs because the rule is matching any method named `execute`, `executeQuery`, `createQuery`, or `query`, regardless of the context. In the false positive example, the `execute` method is part of an `ApiClient` class, which is unrelated to SQL operations. To prevent this, we can add a `pattern-not-inside` to exclude cases where the `execute` method is called on an `ApiClient` object. This ensures that only SQL-related `execute` methods are flagged.\\n\\nWe will add a `pattern-not-inside` pattern to exclude any method calls on `ApiClient` objects.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern: $W.$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: \\\"$CLIENT.execute(...)\\\"\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":443,\"prompt_tokens\":576,\"total_tokens\":1019,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798782428b7af1322b4712086cec2445c998af09a357c8\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive occurs because the rule is matching any method named \\\"execute\\\" regardless of its context. In the false positive example, the `execute` method is from an `ApiClient` class and is not related to SQL operations. To fix this, we need to add a pattern that ensures the method is part of a SQL-related class or context. Specifically, we can add a `pattern-not-inside` to exclude methods from classes like `ApiClient`.\\n\\nThe new pattern `pattern-not-inside: $W = new ApiClient()` will ensure that the rule does not match methods called `execute` when they are inside a context where an `ApiClient` object is instantiated. This will help to exclude non-SQL related `execute` methods from being flagged by the rule.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern: $W.$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: $W = new ApiClient()\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":475,\"prompt_tokens\":576,\"total_tokens\":1051,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "ground_truth": "rules:\n  - id: formatted-sql-string\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A1: Injection\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n      asvs:\n        section: \"V5: Validation, Sanitization and Encoding Verification Requirements\"\n        control_id: 5.3.5 Injection\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n        version: \"4\"\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n      category: security\n      technology:\n        - java\n    message: >-\n      Detected a formatted string in a SQL statement. This could lead to SQL\n      injection if variables in the SQL statement are not properly sanitized.\n      Use a prepared statements (java.sql.PreparedStatement) instead. You\n      can obtain a PreparedStatement using 'connection.prepareStatement'.\n    mode: taint\n    pattern-sources:\n    - patterns:\n      - pattern-either:\n        - pattern: |\n            (HttpServletRequest $REQ)\n        - patterns:\n          - pattern-inside: |\n              $ANNOT $FUNC (..., $INPUT, ...) {\n                ...\n              }\n          - pattern-either:\n            - pattern: (String $INPUT)\n            - pattern: String.format(..., (String $INPUT), ...)\n    pattern-sinks: \n    - patterns:\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n      - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n      - pattern-either:\n        - pattern: (Statement $S).$SQLFUNC(...)\n        - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n        - pattern: (EntityManager $EM).$SQLFUNC(...)\n      - metavariable-regex:\n          metavariable: $SQLFUNC\n          regex: execute|executeQuery|createQuery|query\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/056b59dc/before/formatted-sql-string.yaml", "test_path": "extend_dataset/056b59dc/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}", "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}", "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $W.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern: $W.$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n", "incorrect": "// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        apiClient.execute(call);\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878097f942e386849eac873461595dafd0b135269bd2\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive occurs because the rule is flagging any method named `execute` as a potential SQL injection risk, regardless of the context. In the false positive example, the `execute` method is part of an `ApiClient` class and is used to execute an HTTP call, not a SQL query. To prevent this false positive, we need to add a pattern that excludes methods from `ApiClient` or similar classes that are not related to SQL operations. We can use the `pattern-not-inside` tag to exclude methods within specific classes or contexts that are not relevant to SQL operations.\\n\\nIn this case, we can add a `pattern-not-inside` pattern to exclude methods within the `ApiClient` class. This will ensure that the rule does not flag `execute` methods in `ApiClient` as potential SQL injection risks.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $W.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern: $W.$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n          - pattern-not-inside: $W.$CLIENT.$SQLFUNC(...)\\n            metavariable-regex:\\n              metavariable: $CLIENT\\n              regex: ApiClient|OkHttpClient\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":515,\"prompt_tokens\":576,\"total_tokens\":1091,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"02173997987806794a08c2b5b77fae6b1b30d66cf049efae96507\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class implementing `X509TrustManager` with an empty `checkClientTrusted` method. The current rule misses this case because it only looks for classes that directly implement `X509TrustManager` using the `pattern-inside` directive. To catch anonymous inner classes that implement `X509TrustManager`, we need to add a new pattern that matches such cases. We can use the `pattern-inside` directive to look for patterns where an anonymous inner class implements `X509TrustManager`.\\n\\nThe new pattern will be:\\n```yaml\\npattern-inside: new X509TrustManager() { ... }\\n```\\nThis pattern will ensure that the rule also catches anonymous inner classes that implement `X509TrustManager` and have empty `checkClientTrusted` or `checkServerTrusted` methods.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: new X509TrustManager() { ... }\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":431,\"prompt_tokens\":525,\"total_tokens\":956,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979877677bd229a8365c5529fe9f2bd34de9d5fba20004c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class that implements `X509TrustManager` as an anonymous inner class. The current rule only checks for classes that directly implement `X509TrustManager` using the `pattern-inside` clause. To catch anonymous inner classes that implement `X509TrustManager`, we need to add a new pattern that matches this scenario. The pattern should look for the creation of a new `X509TrustManager` instance and ensure it captures the anonymous class definition.\\n\\nWe will use the `pattern-inside` tag to ensure the rule also applies to anonymous inner classes implementing `X509TrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":390,\"prompt_tokens\":525,\"total_tokens\":915,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878161bb34d08f12c22ff2e1a1a35bb461601b92358f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows an anonymous inner class implementation of `X509TrustManager` where the `checkClientTrusted` method is empty, which is a security vulnerability. The original rule misses this case because it only looks for class implementations that directly implement `X509TrustManager` and not anonymous inner classes. To catch this, we need to add a pattern that matches anonymous inner class implementations of `X509TrustManager`.\\n\\nWe will use the `pattern-inside` tag to ensure that the rule also applies to anonymous inner class implementations of `X509TrustManager`. This will help capture cases where the trust manager is implemented inline within a method or field initialization.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":397,\"prompt_tokens\":525,\"total_tokens\":922,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878248d237d31a05adcf01e52f51c0f328db3e368917\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509TrustManager` and overrides the `checkClientTrusted` method with an empty body. The current rule does not catch this because it only looks for class definitions that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes implementing `X509TrustManager` and overrides the `checkClientTrusted` method with an empty body.\\n\\nThe pattern `pattern-inside: \\\"new X509TrustManager() { ... }\\\"` will ensure that the rule also checks for anonymous inner classes that implement `X509TrustManager`. This will allow the rule to catch the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - patterns:\\n      - pattern: public void checkClientTrusted(...) {}\\n      - pattern-inside: \\\"new X509TrustManager() { ... }\\\"\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":405,\"prompt_tokens\":523,\"total_tokens\":928,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"0217399798778403548e077c37335f09b0de47e6fc4b7f742200c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class that implements `X509TrustManager` and overrides the `checkClientTrusted` method with an empty implementation. However, the current rule does not catch this case because the `pattern-inside` clause expects the class to directly implement `X509TrustManager`, but in the example, the implementation is done via an anonymous inner class. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509TrustManager` with empty `checkClientTrusted` or `checkServerTrusted` methods. We can use the `pattern-inside` tag to ensure the pattern is matched within the context of an anonymous inner class implementing `X509TrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern-inside: |\\n        new X509TrustManager() {\\n          ...\\n          public void checkClientTrusted(...) {}\\n          ...\\n        }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979894,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":418,\"prompt_tokens\":519,\"total_tokens\":937,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979877764bda357bc18307428e648adfc774a7b98ab4001\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows an anonymous inner class implementation of `X509TrustManager` where the `checkServerTrusted` method is empty. The current rule does not catch this because it only looks for class implementations that directly implement `X509TrustManager`. To address this, we need to add a pattern that captures anonymous inner class implementations of `X509TrustManager`. This can be done using the `pattern-inside` tag to ensure that the rule also checks for anonymous inner classes.\\n\\nThe new pattern should look for instances where `X509TrustManager` is implemented anonymously and ensure that the rule still applies to these cases. This will allow the rule to correctly classify the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":406,\"prompt_tokens\":525,\"total_tokens\":931,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"0217399798779411b41ddce50374106f9832e08fc27e0aad46d3f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class implementing `X509TrustManager` with an empty `checkServerTrusted` method. The original rule only checks for classes that explicitly implement `X509TrustManager`, but misses anonymous inner classes. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509TrustManager`. The pattern should look for `new X509TrustManager() { ... }` to ensure we capture these anonymous implementations.\\n\\nHere's the modified rule with the new pattern added:\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":370,\"prompt_tokens\":525,\"total_tokens\":895,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"02173997987783629b56a26b7c7cc53d2969a50d8e0dd51de952b\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows an anonymous inner class implementing `X509TrustManager` with an empty `checkServerTrusted` method. The current rule misses this case because it only looks for `X509TrustManager` implementations in regular class definitions, not in anonymous inner classes. To capture this, we need to add a `pattern-inside` that matches anonymous inner classes implementing `X509TrustManager`.\\n\\nThe new pattern should look for an anonymous inner class that implements `X509TrustManager` and contains the methods we are interested in. This will ensure that the rule catches both regular class implementations and anonymous inner class implementations of `X509TrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":398,\"prompt_tokens\":525,\"total_tokens\":923,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878233f942e386849eac873461595dafd0b13552aa11\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509TrustManager` and overrides the `checkServerTrusted` method with an empty body. The current rule does not catch this because it only looks for patterns inside a named class that implements `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes implementing `X509TrustManager` and having an empty `checkServerTrusted` method. We will use the `pattern-inside` tag to ensure the context of the anonymous inner class is captured correctly.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern-inside: |\\n        new X509TrustManager() {\\n          ...\\n          public void checkServerTrusted(...) {}\\n          ...\\n        }\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":387,\"prompt_tokens\":519,\"total_tokens\":906,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"0217399798773565bada34a84de39d8934d9706b7b4a52054b9fb\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMClass` that implements `X509TrustManager` with an anonymous inner class. The `checkServerTrusted` method is overridden but does not contain any implementation, which should be flagged as insecure. The current rule fails to detect this because it only looks for empty methods within a class that directly implements `X509TrustManager`. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509TrustManager` and ensures that the `checkServerTrusted` method is empty.\\n\\nWe can use the `pattern-inside` tag to match the context of an anonymous inner class implementing `X509TrustManager` and then check for an empty `checkServerTrusted` method within that context.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - patterns:\\n      - pattern: public void checkServerTrusted(...) {}\\n      - pattern-inside: |\\n          new X509TrustManager() {\\n            ...\\n            public void checkServerTrusted(...) {}\\n            ...\\n          }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":431,\"prompt_tokens\":523,\"total_tokens\":954,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878213bb34d08f12c22ff2e1a1a35bb461601b20ef06\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a case where the `X509TrustManager` is implemented as an anonymous inner class, and the `getAcceptedIssuers` method returns `null`. The current rule does not catch this because it only looks for `X509TrustManager` implementations in regular class definitions (using `pattern-inside` with a class declaration). To address this, we need to add a pattern that matches anonymous inner class implementations of `X509TrustManager`. The pattern should look for the creation of a new `X509TrustManager` instance with an anonymous class body.\\n\\nThe new pattern should be added to the `pattern-either` clause to ensure that both regular class definitions and anonymous inner class implementations are covered.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: new X509TrustManager() { ... }\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":406,\"prompt_tokens\":518,\"total_tokens\":924,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878055cc6d8e8c8dad28818dd52d6bee34176e23402c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMClass` that contains an anonymous inner class implementing `X509TrustManager`. The current rule does not catch this case because it only looks for classes that directly implement `X509TrustManager`. To capture anonymous inner classes that implement `X509TrustManager`, we need to add a pattern that matches such cases. Specifically, we should look for patterns where a new instance of `X509TrustManager` is created and methods are overridden.\\n\\nThe pattern `pattern-inside: \\\"new X509TrustManager() { ... }\\\"` will help capture these anonymous inner classes. This pattern will ensure that the rule also matches when `X509TrustManager` is implemented anonymously within a class.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509TrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":410,\"prompt_tokens\":518,\"total_tokens\":928,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"02173997987749447c918fa745a225ec1cc944f80795434ea465b\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMClass` that contains an anonymous inner class implementing `X509TrustManager`. The current rule does not catch this case because it only looks for classes that directly implement `X509TrustManager` using the `pattern-inside` clause. To address this, we need to add a new pattern that matches anonymous inner classes implementing `X509TrustManager`.\\n\\nThe new pattern should be added to the `pattern-either` clause to ensure that both direct implementations and anonymous inner classes are covered. The pattern will look for instances where `new X509TrustManager()` is used, which is typical for anonymous inner classes.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: new X509TrustManager() { ... }\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":390,\"prompt_tokens\":518,\"total_tokens\":908,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878009b1cf128410842ecf79f865f39de803b538fbeb\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a case where the `getAcceptedIssuers` method returns `null`, which is a sign of an insecure trust manager implementation. The current rule already includes a pattern to detect this case, but it is not being matched because the rule is looking for this method inside a class that implements `X509TrustManager` directly. In the false negative example, the method is inside an anonymous inner class that implements `X509TrustManager`.\\n\\nTo correctly classify this case, we need to add a pattern that matches the `getAcceptedIssuers` method inside an anonymous inner class that implements `X509TrustManager`. This can be achieved by using the `pattern-inside` tag to specify the context of the anonymous inner class.\\n\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern-inside: |\\n        new X509TrustManager() {\\n          ...\\n        }\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":411,\"prompt_tokens\":512,\"total_tokens\":923,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - patterns:\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - patterns:\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "type": "fn"}, "response": "{\"id\":\"021739979878213ad73aec5533b25cc813d498f2182ca69e0faf9\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMClass` that contains an anonymous inner class implementing `X509TrustManager`. The rule currently fails to detect this because the `pattern-inside` clause only matches classes that directly implement `X509TrustManager` and have the class body directly following the class declaration. To catch anonymous inner classes that implement `X509TrustManager`, we need to add a `pattern-inside` clause that matches such anonymous class declarations.\\n\\nThe new pattern should look for instances where a new `X509TrustManager` is created anonymously and contains the `getAcceptedIssuers` method returning `null`. This will ensure that the rule catches both direct implementations and anonymous inner class implementations of `X509TrustManager`.\\n\\nThe new pattern should be added as a `pattern-inside` to match the context of an anonymous inner class implementing `X509TrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - patterns:\\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n      - pattern-inside: |\\n          new X509TrustManager() {\\n            ...\\n          }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":441,\"prompt_tokens\":516,\"total_tokens\":957,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987739265ccdfb1aa4d756c762a23f609eb7d36f70747\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `getAcceptedIssuers` method to return `null`. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and overriding the `getAcceptedIssuers` method. We will use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class extending `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":392,\"prompt_tokens\":524,\"total_tokens\":916,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987774225d42797a0eba8ae3ec6fdf400a65d1e3fdec2\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `getAcceptedIssuers` method to return `null`. The current rule misses this case because it only looks for classes that implement `X509TrustManager` directly. To catch this case, we need to add a pattern that looks for anonymous inner classes extending `X509ExtendedTrustManager` and overriding the `getAcceptedIssuers` method.\\n\\nWe will add a `pattern-inside` to capture the anonymous inner class scenario. This will ensure that the rule correctly identifies insecure trust manager implementations even when they are defined as anonymous inner classes extending `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":408,\"prompt_tokens\":524,\"total_tokens\":932,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782121bc9c5b75a94498bdb7e4ccd20bc000130a3c7\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMEClass` that contains an anonymous inner class implementing `X509ExtendedTrustManager`. The current rule only checks for classes that directly implement `X509TrustManager`, but it misses cases where the implementation is done via an anonymous inner class or extends `X509ExtendedTrustManager`. To catch this, we need to add a pattern that looks for anonymous inner classes implementing `X509ExtendedTrustManager`.\\n\\nWe can use the `pattern-inside` tag to ensure that the rule also checks inside anonymous inner classes that implement `X509ExtendedTrustManager`. This will help capture cases where the trust manager is implemented inline, as shown in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":407,\"prompt_tokens\":524,\"total_tokens\":931,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979877829c6c94518f72b95f9e6f29ca665fbbe2344f463\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a class that implements `X509ExtendedTrustManager` instead of `X509TrustManager`, and it has an empty `getAcceptedIssuers` method. The current rule only matches classes that implement `X509TrustManager`, so it misses this case. To correctly classify this example, we need to add a pattern that matches classes implementing `X509ExtendedTrustManager` and includes the empty `getAcceptedIssuers` method.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern-inside: \\\"class $CLASS implements X509ExtendedTrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":359,\"prompt_tokens\":518,\"total_tokens\":877,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - patterns:\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - patterns:\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979877987165f54ed363c80abd130f150bad0145b152c26\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMEClass` that implements an anonymous inner class of `X509ExtendedTrustManager` and overrides the `getAcceptedIssuers` method to return `null`. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager` and does not account for anonymous inner classes or `X509ExtendedTrustManager`.\\n\\nTo fix this, we need to add a pattern that matches anonymous inner classes of `X509ExtendedTrustManager` and overrides the `getAcceptedIssuers` method to return `null`. We can use the `pattern-inside` tag to ensure that the rule also catches these cases.\\n\\nThe new pattern should be added to the `pattern-either` block to cover this scenario.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - patterns:\\n      - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n      - pattern-inside: |\\n          new X509ExtendedTrustManager() {\\n            ...\\n            public X509Certificate[] getAcceptedIssuers() { return null; }\\n            ...\\n          }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":443,\"prompt_tokens\":522,\"total_tokens\":965,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798780299f95a44e5fbd94acd516bc4f00a9884b11fbaf\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The existing rule does not catch this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and overriding the `checkServerTrusted` method with an empty body.\\n\\nWe will use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class extending `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":394,\"prompt_tokens\":528,\"total_tokens\":922,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878082ea6e22211971fe3d61d4d52464fb6420f2d22e\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The existing rule does not catch this case because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty body. This can be achieved by using the `pattern-inside` tag to match the context of the anonymous inner class.\\n\\nThe new pattern will look for anonymous inner classes that implement `X509ExtendedTrustManager` and have an empty `checkServerTrusted` method. This will ensure that the rule correctly identifies the insecure trust manager implementation in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":435,\"prompt_tokens\":528,\"total_tokens\":963,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782432bb6df4d4c74b6bfbeec47d7d3632d277735a7\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides `checkServerTrusted` with an empty body. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty body. We can use the `pattern-inside` tag to ensure the context of the anonymous inner class is captured correctly.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":384,\"prompt_tokens\":528,\"total_tokens\":912,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878245dd9071d86268e73cfde3f0cabaf049b256a57e\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and having empty `checkServerTrusted` or `checkClientTrusted` methods.\\n\\nThe new pattern should be added to the `pattern-either` section to ensure it is considered alongside the existing patterns. This will allow the rule to detect insecure trust manager implementations in both direct and anonymous inner class scenarios.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n    - pattern: |\\n        new X509ExtendedTrustManager() {\\n          @Override\\n          public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\\n        }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979894,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":422,\"prompt_tokens\":522,\"total_tokens\":944,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878055cc6d8e8c8dad28818dd52d6bee34176e946c67\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a case where the `checkServerTrusted` method is implemented but left empty, which is a security vulnerability. The current rule does not catch this because it is looking for the method inside a class that directly implements `X509TrustManager`. However, in the example, the class `TMEClass` creates an anonymous inner class that extends `X509ExtendedTrustManager`, which is a subclass of `X509TrustManager`.\\n\\nTo catch this case, we need to modify the rule to also look for empty `checkServerTrusted` methods inside anonymous inner classes that extend `X509ExtendedTrustManager`. We can achieve this by adding a `pattern-inside` clause that matches the structure of the anonymous inner class.\\n\\nThe new pattern should be added to the `pattern-either` clause to ensure that the rule catches both direct implementations of `X509TrustManager` and anonymous inner classes that extend `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - patterns:\\n      - pattern: public void checkServerTrusted(...) {}\\n      - pattern-inside: |\\n          new X509ExtendedTrustManager() {\\n            ...\\n          }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":458,\"prompt_tokens\":526,\"total_tokens\":984,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987789347e8c3e2b4aa2db09eb5532cedd62c36665132\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule does not catch this because it only looks for classes that implement `X509TrustManager` directly. To address this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty body.\\n\\nWe will use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class implementing `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":397,\"prompt_tokens\":528,\"total_tokens\":925,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987757717f7926a705c89a39195e96fa5611806ca8bd2\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows an anonymous inner class that implements `X509ExtendedTrustManager` with an empty `checkClientTrusted` method. The current rule only matches classes that directly implement `X509TrustManager` and misses anonymous inner classes. To capture this case, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` with empty `checkClientTrusted` or `checkServerTrusted` methods. We'll use `pattern-inside` to ensure we're looking inside the anonymous class declaration.\\n\\nThe added pattern will be:\\n```yaml\\npattern-inside: new X509ExtendedTrustManager() { ... }\\n```\\n\\nThis ensures that the rule will also catch instances where `X509ExtendedTrustManager` is implemented anonymously with empty trust verification methods.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: new X509ExtendedTrustManager() { ... }\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":423,\"prompt_tokens\":528,\"total_tokens\":951,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987821332b8fb9c2ace19b7fe814bde39c812aafe84d4\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` instead of `X509TrustManager`. The current rule only checks for classes that directly implement `X509TrustManager`. To catch this case, we need to add a pattern that looks for anonymous inner classes implementing `X509ExtendedTrustManager` and ensures that the `checkClientTrusted` or `checkServerTrusted` methods are empty.\\n\\nThe new pattern should be added to the `pattern-either` block to cover this scenario. The pattern will look for anonymous inner classes that extend `X509ExtendedTrustManager` and have empty implementations of the trust manager methods.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":401,\"prompt_tokens\":528,\"total_tokens\":929,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987829686d8bc314f8bdcfb1f6fce462bf02e4ac71068\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a class that implements `X509ExtendedTrustManager` and has an empty `checkClientTrusted` method. The current rule is designed to catch empty trust manager implementations but does not account for `X509ExtendedTrustManager`. To fix this, we need to add a pattern that matches classes implementing `X509ExtendedTrustManager` and ensures that the rule catches empty implementations of `checkClientTrusted` in such classes.\\n\\nWe will add a `pattern-inside` clause to match classes implementing `X509ExtendedTrustManager` and ensure that the rule correctly identifies the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - patterns:\\n      - pattern: public void checkClientTrusted(...) {}\\n      - pattern-inside: \\\"class $CLASS implements X509ExtendedTrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":394,\"prompt_tokens\":526,\"total_tokens\":920,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878065999645dcddb1336731c3539e403e8f78d6ea2c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule does not capture this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and overriding `checkClientTrusted` or `checkServerTrusted` with empty implementations.\\n\\nWe will add a new pattern using the `pattern` tag to match anonymous inner classes extending `X509ExtendedTrustManager` and overriding `checkClientTrusted` with an empty body.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: new X509ExtendedTrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) {} }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":406,\"prompt_tokens\":522,\"total_tokens\":928,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987735886d8bc314f8bdcfb1f6fce462bf02e4ab8bab7\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` rather than `X509TrustManager`. The current rule only looks for classes that directly implement `X509TrustManager`, which is why it misses this case. To capture this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager`.\\n\\nThe new pattern should be added to the `pattern-either` block to ensure that both direct implementations of `X509TrustManager` and anonymous inner classes implementing `X509ExtendedTrustManager` are captured. The pattern should look for the creation of a new `X509ExtendedTrustManager` instance and ensure that it is part of an anonymous class definition.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":409,\"prompt_tokens\":531,\"total_tokens\":940,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987821447e8c3e2b4aa2db09eb5532cedd62c361baeee\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` rather than `X509TrustManager`. The original rule only checks for classes that implement `X509TrustManager`. To catch this case, we need to add a pattern that looks for anonymous inner classes implementing `X509ExtendedTrustManager`. The pattern should be placed in the `pattern-either` section to ensure it is considered alongside the existing patterns.\\n\\nThe new pattern will be:\\n```yaml\\n- pattern-inside: \\\"new X509ExtendedTrustManager() { ... }\\\"\\n```\\nThis will ensure that the rule also catches cases where an anonymous inner class implements `X509ExtendedTrustManager` and has empty or insecure implementations of the trust manager methods.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":415,\"prompt_tokens\":531,\"total_tokens\":946,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878238ea6e22211971fe3d61d4d52464fb6420937eeb\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a case where the `X509ExtendedTrustManager` is implemented anonymously within an array initialization. The current rule only looks for classes that directly implement `X509TrustManager`. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager`. This can be done by using the `pattern-inside` tag to ensure that the rule also checks for anonymous implementations within array initializations or similar contexts.\\n\\nHere\u2019s the modified rule:\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":369,\"prompt_tokens\":531,\"total_tokens\":900,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878130a2dfc5ddb10348b5e798c4d80d96f53e2df4ba\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a class that implements `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule is designed to catch empty implementations of `checkClientTrusted` and `checkServerTrusted` methods in classes implementing `X509TrustManager`. However, the example shows a class implementing `X509ExtendedTrustManager`, which is a subclass of `X509TrustManager`. To catch this case, we need to modify the rule to also look for classes implementing `X509ExtendedTrustManager`.\\n\\nWe can add a `pattern-inside` clause to the rule to ensure it also captures classes implementing `X509ExtendedTrustManager`. This will allow the rule to detect empty method implementations in both `X509TrustManager` and `X509ExtendedTrustManager` classes.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: |\\n      class $CLASS implements X509TrustManager {\\n        ...\\n      }\\n  - pattern-inside: |\\n      class $CLASS implements X509ExtendedTrustManager {\\n        ...\\n      }\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - patterns:\\n      - pattern: public void checkClientTrusted(...) {}\\n      - pattern-inside: |\\n          class $CLASS implements X509ExtendedTrustManager {\\n            ...\\n          }\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":455,\"prompt_tokens\":529,\"total_tokens\":984,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878239298efd0f13aa988b32d5247f769efbb386df21\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMEClass` that implements an anonymous inner class of `X509ExtendedTrustManager` with an empty `checkClientTrusted` method. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager` and does not account for anonymous inner classes or `X509ExtendedTrustManager` implementations.\\n\\nTo address this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` with empty `checkClientTrusted` methods. This can be done by adding a new pattern under `pattern-either` that matches the structure of the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: new X509ExtendedTrustManager() { ... public void checkClientTrusted(...) {} }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":398,\"prompt_tokens\":525,\"total_tokens\":923,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987811632b8fb9c2ace19b7fe814bde39c812aa589fab\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows an implementation of `X509ExtendedTrustManager` instead of `X509TrustManager`, which is currently not covered by the rule. The rule only checks for classes that implement `X509TrustManager`. To correctly classify this example, we need to add a pattern that matches classes implementing `X509ExtendedTrustManager`. This can be done by adding a new `pattern-inside` clause that matches classes implementing `X509ExtendedTrustManager`.\\n\\nHere\u2019s the modified rule with the new pattern:\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"class $CLASS implements X509ExtendedTrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":376,\"prompt_tokens\":534,\"total_tokens\":910,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798775171bc9c5b75a94498bdb7e4ccd20bc0001bcb4a3\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule only detects classes that directly implement `X509TrustManager` and have empty implementations of `checkClientTrusted` or `checkServerTrusted`. To correctly classify this example, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` with empty method implementations.\\n\\nWe will add a `pattern-inside` clause to capture the context of an anonymous inner class implementing `X509ExtendedTrustManager`. This will ensure that the rule also catches instances where the trust manager is implemented as an anonymous inner class.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":414,\"prompt_tokens\":534,\"total_tokens\":948,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987814053956ca143ea4b4a14eef7fd9f776a018e2bff\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class implementing `X509ExtendedTrustManager` instead of `X509TrustManager`. The original rule only checks for classes implementing `X509TrustManager`. To catch this case, we need to add a pattern that looks for anonymous inner classes implementing `X509ExtendedTrustManager` and ensures that it has empty implementations of trust manager methods. We can use the `pattern-inside` tag to match the structure of the anonymous inner class.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":364,\"prompt_tokens\":534,\"total_tokens\":898,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - patterns:\n      - pattern: public void checkClientTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878240225aa6952d6004241aafdfe13638693ef4ad2e\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule does not catch this because it only looks for classes that implement `X509TrustManager` directly. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and having an empty `checkClientTrusted` method.\\n\\nThe new pattern should be added under the `pattern-either` section to ensure that both direct implementations of `X509TrustManager` and anonymous inner classes extending `X509ExtendedTrustManager` are covered.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - patterns:\\n      - pattern: public void checkClientTrusted(...) {}\\n      - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":399,\"prompt_tokens\":532,\"total_tokens\":931,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878224cd73a722aa1973f9d1d24e5a6da9aaf795ffc6\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkClientTrusted` method with an empty implementation. The current rule only checks for classes that directly implement `X509TrustManager`. To catch this case, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and having empty `checkClientTrusted` or `checkServerTrusted` methods.\\n\\nWe can use the `pattern` tag to add a new pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and having empty `checkClientTrusted` or `checkServerTrusted` methods.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: new X509ExtendedTrustManager() { ... public void checkClientTrusted(...) {} }\\n    - pattern: new X509ExtendedTrustManager() { ... public void checkServerTrusted(...) {} }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":422,\"prompt_tokens\":528,\"total_tokens\":950,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798774790f858e70892697e940e43cdc5b01ed2bbecc06\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule does not capture this scenario because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that captures anonymous inner classes extending `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. We will use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class extending `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":396,\"prompt_tokens\":531,\"total_tokens\":927,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878086ae4e096c2cc8de22d6661c1655d5c2bf833cb7\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule only catches classes that implement `X509TrustManager` directly, but misses cases where the class extends `X509ExtendedTrustManager`. To fix this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and ensures that the `checkServerTrusted` method is empty.\\n\\nWe will use the `pattern-inside` tag to capture the context of the anonymous inner class and ensure that the method is empty.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979894,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":395,\"prompt_tokens\":531,\"total_tokens\":926,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987821594de96d1828801c6644b74af0176abc69bf38b\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule only looks for classes that directly implement `X509TrustManager`. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method.\\n\\nWe can use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class that implements `X509ExtendedTrustManager`. This will help the rule correctly identify the insecure trust manager implementation in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":405,\"prompt_tokens\":531,\"total_tokens\":936,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782387a3eba3779afacbf4086645566c141b5bf7bc4\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager`. To address this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation.\\n\\nThe new pattern should be added under `pattern-either` to ensure it is considered alongside the existing patterns. The pattern should match the structure of the anonymous inner class and the empty method implementation.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n    - pattern: new X509ExtendedTrustManager() { public void checkServerTrusted(X509Certificate[] $CHAIN, String $AUTH_TYPE, Socket $SOCKET) {} }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":414,\"prompt_tokens\":525,\"total_tokens\":939,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979877671656b4dd7682ceaccc61629f0c4d6a1eb2eabed\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class implementing `X509ExtendedTrustManager` with an empty `checkServerTrusted` method. The current rule does not catch this because it only looks for classes that directly implement `X509TrustManager` and does not account for anonymous inner classes or extended trust managers. To fix this, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` with an empty `checkServerTrusted` method. The pattern should be added under the `pattern-either` clause to ensure it is considered as one of the valid patterns for detecting insecure trust managers.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - patterns:\\n      - pattern: public void checkServerTrusted(...) {}\\n      - pattern-inside: new X509ExtendedTrustManager() { ... }\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":387,\"prompt_tokens\":529,\"total_tokens\":916,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"02173997987774117f7926a705c89a39195e96fa56118067eac80\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that extends `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule does not catch this because it only looks for classes that implement `X509TrustManager` directly. To fix this, we need to add a pattern that matches anonymous inner classes extending `X509ExtendedTrustManager` and ensures that the rule applies to them as well. We can use the `pattern-inside` tag to ensure that the rule matches inside such anonymous inner class definitions.\\n\\nThe new pattern will look for anonymous inner classes extending `X509ExtendedTrustManager` and ensure that the rule applies to them.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":408,\"prompt_tokens\":534,\"total_tokens\":942,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878130c2649323859df38f4624a67d95e983927be336\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The existing rule only checks for classes that implement `X509TrustManager` directly, but not for anonymous inner classes or classes that implement `X509ExtendedTrustManager`. To catch this case, we need to add a pattern that matches anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty body.\\n\\nThe pattern `new X509ExtendedTrustManager() { ... }` will match the anonymous inner class declaration, and we can combine it with the existing patterns to ensure that the rule correctly identifies this insecure implementation.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() { ... }\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":414,\"prompt_tokens\":534,\"total_tokens\":948,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-either:\n    - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979877280cf32e58115cf7c6d8f497ec3d2a684a13fbfa4\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an anonymous inner class that implements `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The original rule misses this case because it only looks for classes that implement `X509TrustManager` directly. To catch this case, we need to add a pattern that looks for anonymous inner classes implementing `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty body.\\n\\nWe can use the `pattern-inside` tag to ensure that the pattern is matched within the context of an anonymous inner class that implements `X509ExtendedTrustManager`. This will help in identifying the insecure implementation in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-either:\\n    - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern-inside: \\\"new X509ExtendedTrustManager() {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979892,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":414,\"prompt_tokens\":534,\"total_tokens\":948,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979878131a2dfc5ddb10348b5e798c4d80d96f53e38bda4\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows a class `TMEClass` that implements an anonymous inner class of `X509ExtendedTrustManager`, which is a subclass of `X509TrustManager`. The current rule is designed to catch empty implementations of `checkClientTrusted` and `checkServerTrusted` methods in classes that directly implement `X509TrustManager`. However, it misses cases where the implementation is done via an anonymous inner class or when the class extends `X509ExtendedTrustManager`.\\n\\nTo address this, we need to add a pattern that captures empty implementations of `checkServerTrusted` in classes that extend `X509ExtendedTrustManager`. This can be done by adding a new pattern that matches the method signature and empty body within an anonymous inner class of `X509ExtendedTrustManager`.\\n\\nThe new pattern should be:\\n```yaml\\npattern: public void checkServerTrusted(X509Certificate[] $CHAIN, String $AUTH_TYPE, SSLEngine $ENGINE) throws CertificateException {}\\n```\\n\\nThis pattern will match the empty implementation of `checkServerTrusted` in the anonymous inner class of `X509ExtendedTrustManager`, thus correctly classifying the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - pattern: public void checkServerTrusted(X509Certificate[] $CHAIN, String $AUTH_TYPE, SSLEngine $ENGINE) throws CertificateException {}\\n    - pattern: public void checkServerTrusted(...) {}\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979897,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":517,\"prompt_tokens\":528,\"total_tokens\":1045,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "insecure-trust-manager", "rule": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "failed_tests": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "failed_type": "fp", "testsuite_a": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "testsuite_b": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n", "ground_truth": "rules:\n- id: insecure-trust-manager\n  metadata:\n    cwe: 'CWE-295: Improper Certificate Validation'\n    owasp: 'A3: Sensitive Data Exposure'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\n    references:\n    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n  message: |\n    Detected empty trust manager implementations. This is dangerous because it accepts any\n    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore\n    and TrustManagerFactory isntead.\n    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https\n    for more information.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern-inside: |\n        class $CLASS implements X509TrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509TrustManager() {\n          ...\n        }\n    - pattern-inside: |\n        class $CLASS implements X509ExtendedTrustManager {\n          ...\n        }\n    - pattern-inside: |\n        new X509ExtendedTrustManager() {\n          ...\n        }\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - pattern: public void checkServerTrusted(...) {}\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n", "rule_path": "extend_dataset/0d124538/before/insecure-trust-manager.yaml", "test_path": "extend_dataset/0d124538/after/insecure-trust-manager.java", "category": "historical", "splited_testsuite_b": ["package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any client connecting (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        //Trust any remote server (no certificate validation)\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\n//cf. https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER\npublic class TrustAllManager implements X509TrustManager {\n\n    // ruleid:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        KeyStore ks = loadKeyStore();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n        tmf.getTrustManagers[0].checkClientTrusted(x509Certificates, s);\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class GoodTrustManager implements X509TrustManager {\n\n    protected KeyStore loadKeyStore() {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        return ks;\n    }\n\n    // ok:insecure-trust-manager\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return loadKeyStore().getCertificate(\"alias\");\n    }\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n                throws CertificateException {\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMClass {\n\n    private static final X509TrustManager TM = new X509TrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n        }\n    }};\n}", "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}"], "actual": [true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false], "expected": [true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: insecure-trust-manager\n  languages:\n  - java\n  message: Detected empty trust manager implementations, which accept any certificate\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\n  patterns:\n  - pattern-inside: \"class $CLASS implements X509TrustManager {\\n  ...\\n}\\n\"\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\n  - pattern-either:\n    - pattern: public void checkClientTrusted(...) {}\n    - patterns:\n      - pattern: public void checkServerTrusted(...) {}\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\n  severity: WARNING\n", "incorrect": "package Trust;\n\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic final class TMEClass {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509ExtendedTrustManager() {\n        // ruleid:insecure-trust-manager\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n        }\n    }};\n}", "type": "fn"}, "response": "{\"id\":\"021739979877829b1cf128410842ecf79f865f39de803b55dab40\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a class that implements `X509ExtendedTrustManager` and overrides the `checkServerTrusted` method with an empty implementation. The current rule only checks for classes that implement `X509TrustManager`. To correctly classify this example, we need to extend the rule to also include classes that implement `X509ExtendedTrustManager`. This can be done by adding a new `pattern-inside` clause to cover classes implementing `X509ExtendedTrustManager`.\\n\\nThe new pattern should be added to ensure that the rule catches empty implementations of `checkServerTrusted` in classes that implement `X509ExtendedTrustManager`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: insecure-trust-manager\\n  languages:\\n  - java\\n  message: Detected empty trust manager implementations, which accept any certificate\\n    and enable man-in-the-middle attacks. Use a KeyStore and TrustManagerFactory instead.\\n    For more details, see https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https.\\n  patterns:\\n  - pattern-inside: \\\"class $CLASS implements X509TrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }\\n  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }\\n  - pattern-either:\\n    - pattern: public void checkClientTrusted(...) {}\\n    - patterns:\\n      - pattern: public void checkServerTrusted(...) {}\\n      - pattern-inside: \\\"class $CLASS implements X509ExtendedTrustManager {\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979891,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":398,\"prompt_tokens\":532,\"total_tokens\":930,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "no-string-eqeq", "rule": "rules:\n- equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  id: no-string-eqeq\n  languages:\n  - java\n  message: Strings should not be compared with '=='; use '.equals()' instead.\n  patterns:\n  - pattern: $X == (String $Y)\n  severity: WARNING\n", "failed_tests": ["```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```", "```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok: no-string-eqeq\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n    }\n}", "testsuite_b": "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        // ok\n        if (b == 2) return -1;\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        //ok\n        if (null == \"hello\") return 12;\n        //ok\n        if (\"hello\" == null) return 0;\n    }\n}", "ground_truth": "rules:\n- id: no-string-eqeq\n  languages: [java]\n  equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  patterns:\n  - pattern-not: null == (String $Y)\n  - pattern: $X == (String $Y)\n  message: |\n    Strings should not be compared with '=='.\n    This is a reference comparison operator. \n    Use '.equals()' instead.\n  severity: WARNING\n", "rule_path": "extend_dataset/b3e044c0/before/no-string-eqeq.yaml", "test_path": "extend_dataset/b3e044c0/after/no-string-eqeq.java", "category": "historical", "splited_testsuite_b": ["public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (a == \"hello\") return 1;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (b == 2) return -1;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ruleid:no-string-eqeq\n        if (\"hello\" == a) return 2;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (null == \"hello\") return 12;\n        return 0;\n    }\n}", "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (\"hello\" == null) return 0;\n        return 0;\n    }\n}"], "actual": [true, false, true, true, false], "expected": [true, false, true, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  id: no-string-eqeq\n  languages:\n  - java\n  message: Strings should not be compared with '=='; use '.equals()' instead.\n  patterns:\n  - pattern: $X == (String $Y)\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\npublic class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (null == \"hello\") return 12;\n        return 0;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- equivalences:\n  - equivalence: $X == $Y ==> $Y == $X\n  id: no-string-eqeq\n  languages:\n  - java\n  message: Strings should not be compared with '=='; use '.equals()' instead.\n  patterns:\n  - pattern: $X == (String $Y)\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "public class Example {\n    public int foo(String a, int b) {\n        // ok:no-string-eqeq\n        if (null == \"hello\") return 12;\n        return 0;\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878301faaf52d26ddeaa45cce709c5997f563838b323\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a comparison between `null` and a string literal using `==`. The current rule flags this as a violation, but it should not, because comparing `null` with a string is a valid operation in Java and does not require the use of `.equals()`. To exclude this case, we can add a `pattern-not` clause to ensure that the rule does not trigger when one of the operands is `null`.\\n\\nThe new pattern should exclude cases where either operand is `null`. This can be achieved by using `pattern-not` with a pattern that matches `null` as one of the operands.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- equivalences:\\n  - equivalence: $X == $Y ==> $Y == $X\\n  id: no-string-eqeq\\n  languages:\\n  - java\\n  message: Strings should not be compared with '=='; use '.equals()' instead.\\n  patterns:\\n  - pattern: $X == (String $Y)\\n  - pattern-not: null == $Y\\n  - pattern-not: $X == null\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979889,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":255,\"prompt_tokens\":315,\"total_tokens\":570,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-system-command", "rule": "rules:\n- id: tainted-system-command\n  languages:\n  - java\n  message: Detected user input entering a method that executes a system command, potentially\n    leading to a command injection vulnerability. This could allow an attacker to\n    inject and execute arbitrary commands on the server, potentially downloading malware\n    or stealing data. Instead, use ProcessBuilder to separate the command into individual\n    arguments, such as `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Ensure\n    the command is hardcoded or restricted to an allowlist to prevent unauthorized\n    execution.\n  mode: taint\n  pattern-sinks:\n  - pattern-either:\n    - pattern: (Runtime $RUNTIME).exec(...)\n    - pattern: (Runtime $RUNTIME).loadLibrary(...)\n    - pattern: Runtime.getRuntime(...).exec(...)\n    - pattern: Runtime.getRuntime(...).loadLibrary(...)\n    - pattern: new ProcessBuilder($ONEARG)\n    - patterns:\n      - pattern: new ProcessBuilder(...)\n      - pattern-not: new ProcessBuilder(\"...\", ...)\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - pattern: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n}"], "failed_type": "fp", "testsuite_a": "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // ruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // ruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        // todoruleid: tainted-system-command\n                        // Indirection, needs interproc taint\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // Case Insensitive\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // e.g Attack\n    // http://localhost:9090/vulnerable/CommandInjectionVulnerability/LEVEL_3?ipaddress=192.168.0.1%20%7c%20cat%20/etc/passwd\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_4, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n    // Payload: 127.0.0.1%0Als\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_%7C_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_5, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\")\n                                        & !requestEntity\n                                                .getUrl()\n                                                .toString()\n                                                .toUpperCase()\n                                                .contains(\"%7C\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @VulnerableAppRequestMapping(\n            value = LevelConstants.LEVEL_6,\n            htmlTemplate = \"LEVEL_1/CI_Level1\",\n            variant = Variant.SECURE)\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && (IP_ADDRESS_PATTERN.matcher(ipAddress).matches()\n                                        || ipAddress.contentEquals(\"localhost\"));\n\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n}\n", "testsuite_b": "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * This class contains vulnerabilities related to Command Injection. <a\n * href=\"https://owasp.org/www-community/attacks/Command_Injection\">For More information</a>\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@VulnerableAppRestController(\n        descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\",\n        value = \"CommandInjection\")\npublic class CommandInjection {\n\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN =\n            Pattern.compile(\"\\\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\\\.|$)){4}\\\\b\");\n\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                process =\n                        // deepruleid: tainted-system-command\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            } else {\n                // ruleid: tainted-system-command\n                process =\n                        new ProcessBuilder(new String[] {\"cmd\", \"/c\", \"ping -n 2 \" + ipAddress})\n                                .redirectErrorStream(true)\n                                .start();\n            }\n            try (BufferedReader bufferedReader =\n                    new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        stringBuilder.toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        // todoruleid: tainted-system-command\n                        // Indirection, needs interproc taint\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // Case Insensitive\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    // e.g Attack\n    // http://localhost:9090/vulnerable/CommandInjectionVulnerability/LEVEL_3?ipaddress=192.168.0.1%20%7c%20cat%20/etc/passwd\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_4, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws ServiceApplicationException, IOException {\n\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n    // Payload: 127.0.0.1%0Als\n    @AttackVector(\n            vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION,\n            description =\n                    \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_%26_%3B_%7C_CASE_INSENSITIVE_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_5, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(\n            @RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity)\n            throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN\n                                        .matcher(requestEntity.getUrl().toString())\n                                        .find()\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%26\")\n                                && !requestEntity.getUrl().toString().toUpperCase().contains(\"%3B\")\n                                        & !requestEntity\n                                                .getUrl()\n                                                .toString()\n                                                .toUpperCase()\n                                                .contains(\"%7C\");\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    @VulnerableAppRequestMapping(\n            value = LevelConstants.LEVEL_6,\n            htmlTemplate = \"LEVEL_1/CI_Level1\",\n            variant = Variant.SECURE)\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(\n            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator =\n                () ->\n                        StringUtils.isNotBlank(ipAddress)\n                                && (IP_ADDRESS_PATTERN.matcher(ipAddress).matches()\n                                        || ipAddress.contentEquals(\"localhost\"));\n\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(\n                new GenericVulnerabilityResponseBean<String>(\n                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),\n                        true),\n                HttpStatus.OK);\n    }\n\n    public static void test1(@RequestParam(IP_ADDRESS) String ipAddress) {\n        String args = \"ping -c 2 \" + ipAddress + \"test\";\n        Process process;\n        // ruleid: tainted-system-command\n        process = new ProcessBuilder(new String[] {\"sh\", \"-c\", args});\n        process.start();\n    }\n\n    public static void test2(@RequestParam String input) {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n\n    public static void test3(@RequestParam String input) {\n        StringBuilder stringBuilder = new StringBuilder(100);\n        stringBuilder.append(input);\n        stringBuilder.append(\"test2\");\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(stringBuilder);\n    }\n\n    public static void test4(@RequestParam String input) {\n        String test1 = \"test\";\n        String comb = test1.concat(input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n\n    public static void test5(@RequestParam String input) {\n        String test1 = \"test\";\n        String comb = String.format(\"%s%s\", test1, input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}\n", "ground_truth": "rules:\n- id: tainted-system-command\n  languages:\n  - java\n  severity: ERROR\n  mode: taint\n  pattern-propagators:\n  - pattern: (StringBuilder $STRB).append($INPUT)\n    from: $INPUT\n    to: $STRB\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: |\n          $METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\n            ...\n          }\n      - pattern-inside: |\n          $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n            ...\n          }\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)\n    - pattern: $SOURCE\n    label: INPUT\n  - patterns:\n    - pattern-either:\n      - pattern: $X + $SOURCE\n      - pattern: $SOURCE + $Y\n      - pattern: (StringBuilder $STRB).append($SOURCE)\n      - pattern: String.format(\"...\", ..., $SOURCE, ...)\n      - pattern: String.join(\"...\", ..., $SOURCE, ...)\n      - pattern: (String $STR).concat($SOURCE)\n      - pattern: $SOURCE.concat(...)\n      - pattern: $X += SOURCE\n      - pattern: $SOURCE += $X\n    label: CONCAT\n    requires: INPUT\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (ProcessBuilder $PB) = new ProcessBuilder(...);\n      - pattern: |\n          (Process $P) = new Process(...);\n      - pattern: |\n          (ProcessBuilder $PB).command(...);\n      - patterns:\n        - pattern-either:\n          - pattern: |\n              (Runtime $R).$EXEC(...);\n          - pattern: |\n               Runtime.getRuntime(...).$EXEC(...);\n        - metavariable-regex:\n            metavariable: $EXEC\n            regex: (exec|loadLibrary|load)\n      - patterns:\n        - pattern: |\n            (ProcessBuilder $PB).command(...).$ADD(...);\n        - metavariable-regex:\n            metavariable: $ADD\n            regex: (add|addAll)\n      - patterns:\n        - pattern-either:\n          - pattern: |\n              $BUILDER = new ProcessBuilder(...);\n              ...\n              $BUILDER.start(...);\n          - pattern: |\n              new ProcessBuilder(...). ... .start(...);\n    requires: CONCAT\n  message: >-\n    Detected user input entering a method which executes a system command.\n    This could result in a command injection vulnerability, which allows an\n    attacker to inject an arbitrary system command onto the server. The attacker\n    could download malware onto or steal data from the server. Instead, use\n    ProcessBuilder, separating the command into individual arguments, like this:\n    `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Further, make sure you\n    hardcode or allowlist the actual command so that attackers can't run arbitrary commands.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    category: security\n    technology:\n    - java\n    - spring\n    confidence: HIGH\n    references:\n    - https://www.stackhawk.com/blog/command-injection-java/\n    - https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n    - https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-078/ExecUnescaped.java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    deepsemgrep: true\n", "rule_path": "extend_dataset/20d71bd1/before/tainted-system-command.yaml", "test_path": "extend_dataset/20d71bd1/after/tainted-system-command.java", "category": "historical", "splited_testsuite_b": ["package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test1(@RequestParam(\"ipaddress\") String ipAddress) throws IOException {\n        String args = \"ping -c 2 \" + ipAddress + \"test\";\n        Process process;\n        // ruleid: tainted-system-command\n        process = new ProcessBuilder(new String[] {\"sh\", \"-c\", args}).start();\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test2(@RequestParam String input) throws IOException {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test4(@RequestParam String input) throws IOException {\n        String test1 = \"test\";\n        String comb = test1.concat(input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test5(@RequestParam String input) throws IOException {\n        String test1 = \"test\";\n        String comb = String.format(\"%s%s\", test1, input);\n        Runtime rt = Runtime.getRuntime();\n        // ruleid: tainted-system-command\n        Process exec = rt.exec(comb);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(@RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (validator.get()) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(stringBuilder.toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(@RequestParam(IP_ADDRESS) String ipAddress) throws IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress);\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (validator.get()) {\n            Process process;\n            if (!isWindows) {\n                // ruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"cmd\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(stringBuilder.toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // deepruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"sh\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(@RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity) throws ServiceApplicationException, IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress) && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN.matcher(requestEntity.getUrl().toString()).find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(this.getResponseFromPingCommand(ipAddress, validator.get()).toString(), true), HttpStatus.OK);\n    }\n}", "package org.sasanlabs.service.vulnerability.commandInjection;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.sasanlabs.internal.utility.LevelConstants;\nimport org.sasanlabs.internal.utility.Variant;\nimport org.sasanlabs.internal.utility.annotations.AttackVector;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;\nimport org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;\nimport org.sasanlabs.service.exception.ServiceApplicationException;\nimport org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;\nimport org.sasanlabs.vulnerability.types.VulnerabilityType;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestParam;\n@VulnerableAppRestController(descriptionLabel = \"COMMAND_INJECTION_VULNERABILITY\", value = \"CommandInjection\")\npublic class CommandInjection {\n    private static final String IP_ADDRESS = \"ipaddress\";\n    private static final Pattern SEMICOLON_SPACE_LOGICAL_AND_PATTERN = Pattern.compile(\"[;& ]\");\n    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(\"\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b\");\n    StringBuilder getResponseFromPingCommand(String ipAddress, boolean isValid) throws IOException {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n        StringBuilder stringBuilder = new StringBuilder();\n        if (isValid) {\n            Process process;\n            if (!isWindows) {\n                // deepruleid: tainted-system-command\n                process = new ProcessBuilder(new String[] {\"cmd\", \"-c\", \"ping -c 2 \" + ipAddress}).redirectErrorStream(true).start();\n            }\n            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                bufferedReader.lines().forEach(val -> stringBuilder.append(val).append(\"\n\"));\n            }\n        }\n        return stringBuilder;\n    }\n    @AttackVector(vulnerabilityExposed = VulnerabilityType.COMMAND_INJECTION, description = \"COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED_IF_SEMICOLON_SPACE_LOGICAL_AND_NOT_PRESENT\")\n    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = \"LEVEL_1/CI_Level1\")\n    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(@RequestParam(IP_ADDRESS) String ipAddress, RequestEntity<String> requestEntity) throws ServiceApplicationException, IOException {\n        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(ipAddress) && !SEMICOLON_SPACE_LOGICAL_AND_PATTERN.matcher(requestEntity.getUrl().toString()).find();\n        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(new GenericVulnerabilityResponseBean<String>(this.getResponseFromPingCommand(ipAddress, validator.get()).toString(), true), HttpStatus.OK);\n    }\n}"], "actual": [true, true, true, true, true, true, true, true], "expected": [true, false, true, true, true, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-system-command\n  languages:\n  - java\n  message: Detected user input entering a method that executes a system command, potentially\n    leading to a command injection vulnerability. This could allow an attacker to\n    inject and execute arbitrary commands on the server, potentially downloading malware\n    or stealing data. Instead, use ProcessBuilder to separate the command into individual\n    arguments, such as `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Ensure\n    the command is hardcoded or restricted to an allowlist to prevent unauthorized\n    execution.\n  mode: taint\n  pattern-sinks:\n  - pattern-either:\n    - pattern: (Runtime $RUNTIME).exec(...)\n    - pattern: (Runtime $RUNTIME).loadLibrary(...)\n    - pattern: Runtime.getRuntime(...).exec(...)\n    - pattern: Runtime.getRuntime(...).loadLibrary(...)\n    - pattern: new ProcessBuilder($ONEARG)\n    - patterns:\n      - pattern: new ProcessBuilder(...)\n      - pattern-not: new ProcessBuilder(\"...\", ...)\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - pattern: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test2(@RequestParam String input) throws IOException {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-system-command\n  languages:\n  - java\n  message: Detected user input entering a method that executes a system command, potentially\n    leading to a command injection vulnerability. This could allow an attacker to\n    inject and execute arbitrary commands on the server, potentially downloading malware\n    or stealing data. Instead, use ProcessBuilder to separate the command into individual\n    arguments, such as `new ProcessBuilder(\"ls\", \"-al\", targetDirectory)`. Ensure\n    the command is hardcoded or restricted to an allowlist to prevent unauthorized\n    execution.\n  mode: taint\n  pattern-sinks:\n  - pattern-either:\n    - pattern: (Runtime $RUNTIME).exec(...)\n    - pattern: (Runtime $RUNTIME).loadLibrary(...)\n    - pattern: Runtime.getRuntime(...).exec(...)\n    - pattern: Runtime.getRuntime(...).loadLibrary(...)\n    - pattern: new ProcessBuilder($ONEARG)\n    - patterns:\n      - pattern: new ProcessBuilder(...)\n      - pattern-not: new ProcessBuilder(\"...\", ...)\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - pattern: $SOURCE\n  severity: ERROR\n", "incorrect": "package org.sasanlabs.service.vulnerability.commandInjection;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestParam;\n\npublic class CommandInjection {\n\n    public static void test2(@RequestParam String input) throws IOException {\n        String latlonCoords = input;\n        Runtime rt = Runtime.getRuntime();\n        // ok: tainted-system-command\n        Process exec = rt.exec(new String[] {\n                \"c:\\path\\to\\latlon2utm.exe\",\n                latlonCoords }); // safe bc args are seperated\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798782721b04abbdcb8df1a677225c44915993c9e328ac\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the use of `Runtime.getRuntime().exec()` with an array of strings, where the command and its arguments are separated. This is a safe usage because it prevents command injection by ensuring that the arguments are not concatenated into a single string. To correctly classify this example, we need to add a `pattern-not` that excludes cases where `exec()` is called with an array of strings. This will ensure that the rule does not flag safe usages of `exec()` with separated arguments.\\n\\nThe new pattern should be added to the `pattern-sinks` section to exclude cases where `exec()` is called with an array of strings.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-system-command\\n  languages:\\n  - java\\n  message: Detected user input entering a method that executes a system command, potentially\\n    leading to a command injection vulnerability. This could allow an attacker to\\n    inject and execute arbitrary commands on the server, potentially downloading malware\\n    or stealing data. Instead, use ProcessBuilder to separate the command into individual\\n    arguments, such as `new ProcessBuilder(\\\"ls\\\", \\\"-al\\\", targetDirectory)`. Ensure\\n    the command is hardcoded or restricted to an allowlist to prevent unauthorized\\n    execution.\\n  mode: taint\\n  pattern-sinks:\\n  - pattern-either:\\n    - pattern: (Runtime $RUNTIME).exec(...)\\n    - pattern: (Runtime $RUNTIME).loadLibrary(...)\\n    - pattern: Runtime.getRuntime(...).exec(...)\\n    - pattern: Runtime.getRuntime(...).loadLibrary(...)\\n    - pattern: new ProcessBuilder($ONEARG)\\n    - patterns:\\n      - pattern: new ProcessBuilder(...)\\n      - pattern-not: new ProcessBuilder(\\\"...\\\", ...)\\n    - pattern-not: Runtime.getRuntime().exec(new String[] { ... })\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ($LOOKUP) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - pattern: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979898,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":536,\"prompt_tokens\":653,\"total_tokens\":1189,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "xmlinputfactory", "rule": "rules:\n- id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n  languages:\n  - java\n  message: '\n\n    XMLInputFactory instantiated without disabling entity processing via setProperty\n    functions.\n\n    '\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XMLFACTORY.setProperty(\\\"\\\n      javax.xml.stream.isSupportingExternalEntities\\\", false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: '$XMLFACTORY = $W.newInstance(...);\n\n      ...\n\n      $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n\n      '\n  - pattern-either:\n    - pattern: $XMLFACTORY = $W.newFactory(...);\n    - pattern: $XMLFACTORY = new XMLInputFactory(...);\n    - pattern: $XMLFACTORY = SAXParserFactory.newInstance(...);\n    - pattern: $XMLFACTORY = DocumentBuilderFactory.newInstance(...);\n  severity: WARNING\n", "failed_tests": ["package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/xmlReader/vuln\")\n    public String xmlReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n            return \"xmlReader xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/xmlReader/sec\", method = RequestMethod.POST)\n    public String xmlReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml\n\n            // fix code start\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            //fix code end\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"xmlReader xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/vuln\", method = RequestMethod.POST)\n    public String SAXBuilderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXBuilder builder = new SAXBuilder();\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));  // cause xxe\n            return \"SAXBuilder xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXBuilder/sec\", method = RequestMethod.POST)\n    public String SAXBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXBuilder builder = new SAXBuilder();\n            builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.jdom2.Document document\n            builder.build(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXBuilder xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/vuln\", method = RequestMethod.POST)\n    public String SAXReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            SAXReader reader = new SAXReader();\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body))); // cause xxe\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"SAXReader xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/SAXReader/sec\", method = RequestMethod.POST)\n    public String SAXReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            SAXReader reader = new SAXReader();\n            reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            // org.dom4j.Document document\n            reader.read(new InputSource(new StringReader(body)));\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXReader xxe security code\";\n    }\n\n    @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST)\n    public String SAXParserVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n\n            return \"SAXParser xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST)\n    public String SAXParserSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            SAXParser parser = spf.newSAXParser();\n            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"SAXParser xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/Digester/vuln\", method = RequestMethod.POST)\n    public String DigesterVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            Digester digester = new Digester();\n            digester.parse(new StringReader(body));  // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"Digester xxe vuln code\";\n    }\n\n    @RequestMapping(value = \"/Digester/sec\", method = RequestMethod.POST)\n    public String DigesterSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            Digester digester = new Digester();\n            digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            digester.parse(new StringReader(body));  // parse xml\n\n            return \"Digester xxe security code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // \u6709\u56de\u663e\n    @RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln01(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // \u904d\u5386xml\u8282\u70b9name\u548cvalue\n            StringBuilder buf = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent()));\n                }\n            }\n            sr.close();\n            return buf.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    // \u6709\u56de\u663e\n    @RequestMapping(value = \"/DocumentBuilder/vuln02\", method = RequestMethod.POST)\n    public String DocumentBuilderVuln02(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            // \u904d\u5386xml\u8282\u70b9name\u548cvalue\n            StringBuilder result = new StringBuilder();\n            NodeList rootNodeList = document.getChildNodes();\n            for (int i = 0; i < rootNodeList.getLength(); i++) {\n                Node rootNode = rootNodeList.item(i);\n                NodeList child = rootNode.getChildNodes();\n                for (int j = 0; j < child.getLength(); j++) {\n                    Node node = child.item(j);\n                    // \u6b63\u5e38\u89e3\u6790XML\uff0c\u9700\u8981\u5224\u65ad\u662f\u5426\u662fELEMENT_NODE\u7c7b\u578b\u3002\u5426\u5219\u4f1a\u51fa\u73b0\u591a\u4f59\u7684\u7684\u8282\u70b9\u3002\n                    if (child.item(j).getNodeType() == Node.ELEMENT_NODE) {\n                        result.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getFirstChild()));\n                    }\n                }\n            }\n            sr.close();\n            return result.toString();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/Sec\", method = RequestMethod.POST)\n    public String DocumentBuilderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            db.parse(is);  // parse xml\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xxe security code\";\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/vuln\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setXIncludeAware(true);   // \u652f\u6301XInclude\n            dbf.setNamespaceAware(true);  // \u652f\u6301XInclude\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n            return \"DocumentBuilder xinclude xxe vuln code\";\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n    }\n\n\n    @RequestMapping(value = \"/DocumentBuilder/xinclude/sec\", method = RequestMethod.POST)\n    public String DocumentBuilderXincludeSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n            dbf.setXIncludeAware(true);   // \u652f\u6301XInclude\n            dbf.setNamespaceAware(true);  // \u652f\u6301XInclude\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            StringReader sr = new StringReader(body);\n            InputSource is = new InputSource(sr);\n            Document document = db.parse(is);  // parse xml\n\n            NodeList rootNodeList = document.getChildNodes();\n            response(rootNodeList);\n\n            sr.close();\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"DocumentBuilder xinclude xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/vuln\")\n    public String XMLReaderVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLReader xxe vuln code\";\n    }\n\n\n    @PostMapping(\"/XMLReader/sec\")\n    public String XMLReaderSec(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser saxParser = spf.newSAXParser();\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            xmlReader.parse(new InputSource(new StringReader(body)));\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n        return \"XMLReader xxe security code\";\n    }\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n    /**\n     * \u4fee\u590d\u8be5\u6f0f\u6d1e\u53ea\u9700\u5347\u7ea7dom4j\u52302.1.1\u53ca\u4ee5\u4e0a\uff0c\u8be5\u7248\u672c\u53ca\u4ee5\u4e0a\u7981\u7528\u4e86ENTITY\uff1b\n     * \u4e0d\u5e26ENTITY\u7684PoC\u4e0d\u80fd\u5229\u7528\uff0c\u6240\u4ee5\u7981\u7528ENTITY\u5373\u53ef\u5b8c\u6210\u4fee\u590d\u3002\n     */\n    @PostMapping(\"/DocumentHelper/vuln\")\n    public String DocumentHelper(HttpServletRequest req) {\n        try {\n            String body = WebUtils.getRequestBody(req);\n            DocumentHelper.parseText(body); // parse xml\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"DocumentHelper xxe vuln code\";\n    }\n\n\n    private static void response(NodeList rootNodeList){\n        for (int i = 0; i < rootNodeList.getLength(); i++) {\n            Node rootNode = rootNodeList.item(i);\n            NodeList xxe = rootNode.getChildNodes();\n            for (int j = 0; j < xxe.getLength(); j++) {\n                Node xxeNode = xxe.item(j);\n                // \u6d4b\u8bd5\u4e0d\u80fdblind xxe\uff0c\u6240\u4ee5\u5f3a\u884c\u52a0\u4e86\u4e00\u4e2a\u56de\u663e\n                logger.info(\"xxeNode: \" + xxeNode.getNodeValue());\n            }\n\n        }\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "testsuite_b": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix1\")\n    public String XMLInputFactoryFix1(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.supportDTD\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix2\")\n    public String XMLInputFactoryFix2(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    @PostMapping(\"/XMLInputFactory/fix3\")\n    public String XMLInputFactoryFix3(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n\n    public static void main(String[] args)  {\n    }\n\n}\n", "ground_truth": "rules:\n  - id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n    severity: WARNING\n    metadata:\n      cwe: \"CWE-611: Improper Restriction of XML External Entity Reference\"\n      owasp:\n        - A04:2021 - XML External Entities (XXE)\n      references:\n        - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n      category: security\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      technology: [java]\n    message:\n      XMLInputFactory being instantiated without calling the setProperty functions\n      that are generally used for disabling entity processing\n    patterns:\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            ...\n          }\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            ...\n          }\n      - pattern-not-inside: |\n          $RETURNTYPE $METHOD(...) {\n            ...\n            $XMLFACTORY.setProperty(\"javax.xml.stream.supportDTD\", false);\n            ...\n          }\n      - pattern-not-inside: |\n          $XMLFACTORY = $W.newInstance(...);\n          ...\n          $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n      - pattern-either:\n          - pattern: $XMLFACTORY = XMLInputFactory.newFactory(...);\n          - pattern: $XMLFACTORY = new XMLInputFactory(...);\n          - pattern: $XMLFACTORY = XMLInputFactory.newInstance(...);\n    languages:\n      - java\n", "rule_path": "extend_dataset/5b4e5660/before/xmlinputfactory.yaml", "test_path": "extend_dataset/5b4e5660/after/xmlinputfactory.java", "category": "historical", "splited_testsuite_b": ["package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix1\")\n    public String XMLInputFactoryFix1(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.supportDTD\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix2\")\n    public String XMLInputFactoryFix2(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/fix3\")\n    public String XMLInputFactoryFix3(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ok:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            xmlInputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    public static SortingMachine<Map.Pair<String, Integer>> shorten(\n            SortingMachine<Map.Pair<String, Integer>> sortMachine, int num) {\n        assert sortMachine != null : \"Violation of: sortMachine is not null\";\n        assert num <= sortMachine\n                .size() : \"Violation of: N <= size of sortMachine\";\n        // ok: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n        SortingMachine<Map.Pair<String, Integer>> shortenedSM = sortMachine\n                .newInstance();\n        int i = 0;\n\n        //creates a new sortingMachine that only contains the N elements desired\n        //by the user\n        for (Map.Pair<String, Integer> pair : sortMachine) {\n            if (i < num) {\n                shortenedSM.add(pair);\n            }\n            i++;\n        }\n        return shortenedSM;\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}"], "actual": [false, false, false, false, false], "expected": [true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n  languages:\n  - java\n  message: '\n\n    XMLInputFactory instantiated without disabling entity processing via setProperty\n    functions.\n\n    '\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XMLFACTORY.setProperty(\\\"\\\n      javax.xml.stream.isSupportingExternalEntities\\\", false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: '$XMLFACTORY = $W.newInstance(...);\n\n      ...\n\n      $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n\n      '\n  - pattern-either:\n    - pattern: $XMLFACTORY = $W.newFactory(...);\n    - pattern: $XMLFACTORY = new XMLInputFactory(...);\n    - pattern: $XMLFACTORY = SAXParserFactory.newInstance(...);\n    - pattern: $XMLFACTORY = DocumentBuilderFactory.newInstance(...);\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\n  languages:\n  - java\n  message: '\n\n    XMLInputFactory instantiated without disabling entity processing via setProperty\n    functions.\n\n    '\n  patterns:\n  - pattern-not-inside: \"$RETURNTYPE $METHOD(...) {\\n  ...\\n  $XMLFACTORY.setProperty(\\\"\\\n      javax.xml.stream.isSupportingExternalEntities\\\", false);\\n  ...\\n}\\n\"\n  - pattern-not-inside: '$XMLFACTORY = $W.newInstance(...);\n\n      ...\n\n      $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n\n      '\n  - pattern-either:\n    - pattern: $XMLFACTORY = $W.newFactory(...);\n    - pattern: $XMLFACTORY = new XMLInputFactory(...);\n    - pattern: $XMLFACTORY = SAXParserFactory.newInstance(...);\n    - pattern: $XMLFACTORY = DocumentBuilderFactory.newInstance(...);\n  severity: WARNING\n", "incorrect": "package org.joychou.controller;\n\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.io.SAXReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.XMLReader;\n\nimport java.io.*;\n\nimport org.xml.sax.InputSource;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.SAXParser;\n\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.apache.commons.digester3.Digester;\nimport org.jdom2.input.SAXBuilder;\nimport org.joychou.util.WebUtils;\n\n/**\n * Java xxe vuln and security code.\n *\n * @author JoyChou @2017-12-22\n */\n\n@RestController\n@RequestMapping(\"/xxe\")\npublic class XXE {\n\n    private static Logger logger = LoggerFactory.getLogger(XXE.class);\n    private static String EXCEPT = \"xxe except\";\n\n    @PostMapping(\"/XMLInputFactory/vuln\")\n    public String XMLInputFactoryVuln(HttpServletRequest request) {\n        try {\n            String body = WebUtils.getRequestBody(request);\n            logger.info(body);\n            // ruleid:owasp.java.xxe.javax.xml.stream.XMLInputFactory\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(new StringReader(body));\n            reader.nextTag();\n\n        } catch (Exception e) {\n            logger.error(e.toString());\n            return EXCEPT;\n        }\n\n        return \"XMLInputFactory xxe vuln code\";\n    }\n\n    public static void main(String[] args)  {\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"02173997987773047e8c3e2b4aa2db09eb5532cedd62c3697bff9\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example shows that the `XMLInputFactory` is instantiated without disabling entity processing, which should be flagged by the rule. However, the current rule does not catch this because the `pattern-not-inside` clauses are too restrictive. Specifically, the rule excludes cases where the `setProperty` method is called within a method or after a `newInstance` call, but it doesn't account for cases where the `setProperty` method is not called at all.\\n\\nTo fix this, we need to add a `pattern-not` clause to exclude cases where the `setProperty` method is called directly after the `XMLInputFactory` instantiation. This will ensure that the rule catches instances where the `setProperty` method is not called, even if it is not inside a method or after a `newInstance` call.\\n\\nHere is the modified rule:\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: owasp.java.xxe.javax.xml.stream.XMLInputFactory\\n  languages:\\n  - java\\n  message: '\\n\\n    XMLInputFactory instantiated without disabling entity processing via setProperty\\n    functions.\\n\\n    '\\n  patterns:\\n  - pattern-not-inside: \\\"$RETURNTYPE $METHOD(...) {\\\\n  ...\\\\n  $XMLFACTORY.setProperty(\\\\\\\"\\\\\\n      javax.xml.stream.isSupportingExternalEntities\\\\\\\", false);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not-inside: '$XMLFACTORY = $W.newInstance(...);\\n\\n      ...\\n\\n      $XMLFACTORY.setProperty(\\\"javax.xml.stream.isSupportingExternalEntities\\\", false);\\n\\n      '\\n  - pattern-not: '$XMLFACTORY = $W.newInstance(...); $XMLFACTORY.setProperty(\\\"javax.xml.stream.isSupportingExternalEntities\\\", false);'\\n  - pattern-either:\\n    - pattern: $XMLFACTORY = $W.newFactory(...);\\n    - pattern: $XMLFACTORY = new XMLInputFactory(...);\\n    - pattern: $XMLFACTORY = SAXParserFactory.newInstance(...);\\n    - pattern: $XMLFACTORY = DocumentBuilderFactory.newInstance(...);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979895,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":475,\"prompt_tokens\":833,\"total_tokens\":1308,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - patterns:\n      - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n          \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - patterns:\n      - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n          \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "incorrect": "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987822186d8bc314f8bdcfb1f6fce462bf02e4aef15ef\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a method `buildConstraintViolationWithTemplate` that takes a dynamic input `message` and uses it to build a constraint violation. This pattern is not currently covered by the existing rule, which focuses on `ExpressionFactory` and its methods like `createValueExpression` and `createMethodExpression`.\\n\\nTo correctly classify this example, we need to add a new pattern that matches the `buildConstraintViolationWithTemplate` method call with a dynamic input. We will use the `pattern` tag to add this new pattern.\\n\\nThe new pattern will match any method that calls `buildConstraintViolationWithTemplate` with a dynamic input, ensuring that the rule correctly identifies this as a potential expression language (EL) injection vulnerability.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: el-injection\\n  languages:\\n  - java\\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\\n    to prevent unfiltered input from entering the risky code evaluation.\\n  patterns:\\n  - pattern-either:\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n    ...\\\\n \\\\\\n        \\\\ }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - patterns:\\n      - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n          \\\\  $EF.createValueExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n      - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CONTEXT.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n    ...\\\\n\\\\\\n        \\\\  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979909,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":983,\"prompt_tokens\":1040,\"total_tokens\":2023,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "incorrect": "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987814730d8ab2c790a81e01752f77c1064b3e13ce1de\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a method `buildConstraintViolationWithTemplate` that takes a dynamic input `message`, which could potentially lead to EL injection if the input is not properly sanitized. The current rule focuses on `ExpressionFactory` and its methods like `createValueExpression` and `createMethodExpression`, but it does not cover this case. To correctly classify this example, we need to add a pattern that captures the use of `buildConstraintViolationWithTemplate` with a dynamic input.\\n\\nWe will add a new pattern using the `pattern` tag to match the `buildConstraintViolationWithTemplate` method call with a dynamic argument.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: el-injection\\n  languages:\\n  - java\\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\\n    to prevent unfiltered input from entering the risky code evaluation.\\n  patterns:\\n  - pattern-either:\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n    ...\\\\n \\\\\\n        \\\\ }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createValueExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n    ...\\\\n\\\\\\n        \\\\  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CONTEXT.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979913,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":960,\"prompt_tokens\":1036,\"total_tokens\":1996,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "incorrect": "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979877391dad65b139fe14e2b5baa3f17b8f3d4e6775954\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a method `buildConstraintViolationWithTemplate` that takes a dynamic input `message`, which could potentially lead to an Expression Language (EL) injection. The current rule does not cover this case because it only looks for `ExpressionFactory` usage. To correctly classify this example, we need to add a new pattern that matches the `buildConstraintViolationWithTemplate` method with a dynamic input.\\n\\nWe will use the `pattern` tag to add this new pattern. The pattern will match any method that calls `buildConstraintViolationWithTemplate` with a dynamic input, ensuring that the rule can catch this type of EL injection.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: el-injection\\n  languages:\\n  - java\\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\\n    to prevent unfiltered input from entering the risky code evaluation.\\n  patterns:\\n  - pattern-either:\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n    ...\\\\n \\\\\\n        \\\\ }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CTX.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createValueExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n    ...\\\\n\\\\\\n        \\\\  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979912,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":961,\"prompt_tokens\":1036,\"total_tokens\":1997,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - patterns:\n      - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n          \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - patterns:\n      - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n          \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "incorrect": "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878091032553db7aa845d610724dd29b9d6d7cc7dcff\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a method `buildConstraintViolationWithTemplate` that takes a dynamic `message` parameter, which could lead to Expression Language (EL) injection if the input is not properly sanitized. The current rule does not capture this pattern because it only looks for `ExpressionFactory.createValueExpression` and `ExpressionFactory.createMethodExpression`. To address this, we need to add a new pattern that captures the `buildConstraintViolationWithTemplate` method call with a dynamic input.\\n\\nWe will add a new pattern using the `pattern` tag to match the `buildConstraintViolationWithTemplate` method call with a dynamic parameter.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: el-injection\\n  languages:\\n  - java\\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\\n    to prevent unfiltered input from entering the risky code evaluation.\\n  patterns:\\n  - pattern-either:\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n    ...\\\\n \\\\\\n        \\\\ }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - patterns:\\n      - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n          \\\\  $EF.createValueExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n      - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CONTEXT.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n    ...\\\\n\\\\\\n        \\\\  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979913,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":963,\"prompt_tokens\":1040,\"total_tokens\":2003,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "el-injection", "rule": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "failed_tests": ["package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}"], "failed_type": "fp", "testsuite_a": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}\n", "testsuite_b": "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}\n", "ground_truth": "rules:\n- id: el-injection\n  metadata:\n    cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n    owasp: 'A1: Injection'\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION\n    category: security\n  message: |\n    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-either:\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createValueExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createValueExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        class $CLASS {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $X $METHOD(...) {\n            ...\n            $EF.createMethodExpression($CTX,$INPUT,...);\n            ...\n          }\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...) {\n          ...\n          ExpressionFactory $EF = ...;\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(...,ExpressionFactory $EF,...) {\n          ...\n          $EF.createMethodExpression($CTX,$INPUT,...);\n          ...\n        }\n    - pattern: |\n        $X $METHOD(String $INPUT, ...) {\n          ...\n          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n          ...\n        }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createValueExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createValueExpression($CTX,$S,...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        $EF.createMethodExpression($CTX,\"...\",...);\n        ...\n      }\n  - pattern-not: |\n      $X $METHOD(...) {\n        ...\n        String $S = \"...\";\n        ...\n        $EF.createMethodExpression($CTX,$S,...);\n        ...\n      }\n", "rule_path": "extend_dataset/534faf01/before/el-injection.yaml", "test_path": "extend_dataset/534faf01/after/el-injection.java", "category": "historical", "splited_testsuite_b": ["package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeEL(String expression) {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.faces.context.FacesContext;\n\npublic class ElExpressionSample {\n\n    // ok: el-injection\n    public void safeEL() {\n        FacesContext context = FacesContext.getCurrentInstance();\n        ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();\n        ELContext elContext = context.getELContext();\n        ValueExpression vex = expressionFactory.createValueExpression(elContext, \"1+1\", String.class);\n        String result = (String) vex.getValue(elContext);\n        System.out.println(result);\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    // ruleid: el-injection\n    public void unsafeELMethod(ELContext elContext,ExpressionFactory expressionFactory, String expression) {\n        expressionFactory.createMethodExpression(elContext, expression, String.class, new Class[]{Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.el.ELContext;\nimport javax.el.ExpressionFactory;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    public void safeELMethod(ELContext elContext,ExpressionFactory expressionFactory) {\n        expressionFactory.createMethodExpression(elContext, \"1+1\", String.class,new Class[] {Integer.class});\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ok: el-injection\n    private void safeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(\"somestring\")\n             .addConstraintViolation();\n    }\n}"], "actual": [true, false, true, false, false, false], "expected": [true, false, true, false, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\npackage testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: el-injection\n  languages:\n  - java\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\n    to prevent unfiltered input from entering the risky code evaluation.\n  patterns:\n  - pattern-either:\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n    ...\\n \\\n        \\ }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createValueExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createValueExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF;\\n  ...\\n  $X $METHOD(...)\\\n        \\ {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n    ...\\n\\\n        \\  }\\n  ...\\n}\\n\"\n    - pattern: \"class $CLASS {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n  $X\\\n        \\ $METHOD(...) {\\n    ...\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\    ...\\n  }\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...) {\\n  ...\\n  ExpressionFactory $EF = ...;\\n  ...\\n\\\n        \\  $EF.createMethodExpression($CTX,$INPUT,...);\\n  ...\\n}\\n\"\n    - pattern: \"$X $METHOD(...,ExpressionFactory $EF,...) {\\n  ...\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\n\\\n        \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createValueExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createValueExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  $EF.createMethodExpression($CTX,\\\"...\\\"\\\n      ,...);\\n  ...\\n}\\n\"\n  - pattern-not: \"$X $METHOD(...) {\\n  ...\\n  String $S = \\\"...\\\";\\n  ...\\n  $EF.createMethodExpression($CTX,$S,...);\\n\\\n      \\  ...\\n}\\n\"\n  severity: WARNING\n", "incorrect": "package testcode.script;\n\nimport javax.validation.ConstraintValidatorContext;\n\npublic class ElExpressionSample {\n\n    //ruleid: el-injection\n    private void unsafeELTemplate(String message, ConstraintValidatorContext context) {\n         context.disableDefaultConstraintViolation();\n         context\n             .someMethod()\n             .buildConstraintViolationWithTemplate(message)\n             .addConstraintViolation();\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878022eb45c75a82413712b34970e7f4af8f2dec6098\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a method `buildConstraintViolationWithTemplate` that uses a dynamic input `message` to build a constraint violation. This is similar to the EL injection patterns in the existing rule, but it doesn't involve `ExpressionFactory`. To catch this case, we need to add a new pattern that matches the method `buildConstraintViolationWithTemplate` with a dynamic input.\\n\\nThe new pattern should be added to the `pattern-either` section to ensure it is considered as a potential match for the rule. The pattern will look for the method `buildConstraintViolationWithTemplate` being called with a dynamic input, which is represented by the metavariable `$INPUT`.\\n\\nHere is the new pattern to be added:\\n```yaml\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CTX.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n```\\n\\nThis pattern will match methods that call `buildConstraintViolationWithTemplate` with a dynamic input, which is exactly the case in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: el-injection\\n  languages:\\n  - java\\n  message: An expression is built with a dynamic value. Verify the source of the value(s)\\n    to prevent unfiltered input from entering the risky code evaluation.\\n  patterns:\\n  - pattern-either:\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n    ...\\\\n \\\\\\n        \\\\ }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createValueExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $CTX.buildConstraintViolationWithTemplate($INPUT);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF;\\\\n  ...\\\\n  $X $METHOD(...)\\\\\\n        \\\\ {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n    ...\\\\n\\\\\\n        \\\\  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"class $CLASS {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n  $X\\\\\\n        \\\\ $METHOD(...) {\\\\n    ...\\\\n    $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\    ...\\\\n  }\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  ExpressionFactory $EF = ...;\\\\n  ...\\\\n\\\\\\n        \\\\  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n  ...\\\\n}\\\\n\\\"\\n    - pattern: \\\"$X $METHOD(...,ExpressionFactory $EF,...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$INPUT,...);\\\\n\\\\\\n        \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createValueExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createValueExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,\\\\\\\"...\\\\\\\"\\\\\\n      ,...);\\\\n  ...\\\\n}\\\\n\\\"\\n  - pattern-not: \\\"$X $METHOD(...) {\\\\n  ...\\\\n  String $S = \\\\\\\"...\\\\\\\";\\\\n  ...\\\\n  $EF.createMethodExpression($CTX,$S,...);\\\\n\\\\\\n      \\\\  ...\\\\n}\\\\n\\\"\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979917,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":1053,\"prompt_tokens\":1036,\"total_tokens\":2089,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798781418e27326e927d3bbfd5c6dfd7e0a384e418511a\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec` call where the command is \\\"bash\\\" and the environment variables are passed as an array. The current rule does not catch this because it lacks a pattern that matches `Runtime.getRuntime().exec` with a shell command (like \\\"bash\\\") and environment variables. To address this, we need to add a new pattern that matches such cases. The new pattern should capture the scenario where `Runtime.getRuntime().exec` is called with a shell command and environment variables.\\n\\nThe new pattern will be:\\n```yaml\\n- pattern: $RUNTIME.exec($CMD, $ENVP, $ARG);\\n```\\nThis pattern will match the case where `Runtime.getRuntime().exec` is called with a command, environment variables, and arguments, which is exactly what the false negative example does.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec($CMD, $ENVP, $ARG);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":750,\"prompt_tokens\":786,\"total_tokens\":1536,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987755066073dc41e70fd41625606b276ce9fb978606f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the command is directly specified as \\\"bash\\\" and additional arguments are passed in an array. The current rule does not catch this case because it focuses on string concatenation, `String.format`, and specific shell commands but misses direct calls with shell commands as arguments. To address this, we need to add a pattern that matches direct calls to `exec` with a shell command as the first argument.\\n\\nThe new pattern should match `$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", ...)` to ensure that direct calls with shell commands are detected. This will help in identifying cases where a shell command is directly passed as an argument to `exec`, which is a potential command injection risk.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: $RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", ...)\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979905,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":757,\"prompt_tokens\":786,\"total_tokens\":1543,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878066c038e14dcafb30bd771c014e08fe6acc47da15\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec(\\\"bash\\\", envp, input)` call, where the first argument is a shell command (\\\"bash\\\") and the third argument is a user-controlled variable (`input`). This is a potential command injection vulnerability because the user-controlled input is passed directly to the shell command.\\n\\nTo catch this case, we need to add a pattern that matches `Runtime.getRuntime().exec($CMD, $ENVP, $ARG)` where `$CMD` is a shell command (e.g., \\\"bash\\\", \\\"sh\\\", etc.) and `$ARG` is a user-controlled variable. This can be achieved by adding a new pattern that matches this specific structure.\\n\\nThe new pattern will be:\\n```yaml\\n- pattern: '$RUNTIME.exec($CMD, $ENVP, $ARG)'\\n```\\nThis pattern will match cases where the first argument is a shell command, the second argument is an environment variable array, and the third argument is a user-controlled variable, which is the structure in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec($CMD, $ENVP, $ARG)'\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979906,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":795,\"prompt_tokens\":786,\"total_tokens\":1581,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979877548fc604de8dc24f5715d74121cf304c2b2186451\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the first argument is a shell command (\\\"bash\\\") and the third argument is a user-controlled variable (`input`). The current rule does not catch this pattern because it does not account for the case where the shell command is directly passed as a string literal without concatenation or formatting.\\n\\nTo address this, we need to add a new pattern that matches `Runtime.getRuntime().exec()` calls where the first argument is a shell command (e.g., \\\"bash\\\", \\\"sh\\\", etc.) and there are additional arguments that could be user-controlled. This can be achieved by adding a `pattern` that matches such calls directly.\\n\\nThe new pattern should look for `$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", ...)` to ensure that any shell command passed directly as a string is caught, along with any additional arguments that could be user-controlled.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: $RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", ...)\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979906,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":789,\"prompt_tokens\":786,\"total_tokens\":1575,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878178164a27376a8ae6eee5d7d6e495732466127228\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a direct call to `Runtime.getRuntime().exec(\\\"bash\\\", envp, input)`, where the first argument is a shell command (\\\"bash\\\") and the third argument is a user-controlled variable (`input`). The current rule does not catch this case because it does not account for the scenario where the shell command is directly passed as a string literal in the `exec` method without concatenation or formatting.\\n\\nTo address this, we need to add a new pattern that matches `$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", $ENVP, $ARG)` where `$ENVP` is an environment variable array and `$ARG` is a user-controlled argument. This pattern will ensure that the rule correctly identifies cases where a shell command is directly passed to `exec` along with user-controlled arguments.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\", $ENVP, $ARG)'\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979909,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":779,\"prompt_tokens\":786,\"total_tokens\":1565,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987824317f7926a705c89a39195e96fa561180642cd4e\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec(command, envp, input)` call where `command` and `envp` are arrays, and `input` is a variable that could be user-controlled. The current rule does not catch this pattern because it does not account for the case where `exec` is called with three arguments: two arrays and a variable. To address this, we need to add a new pattern that matches this specific case.\\n\\nWe will use the `pattern` tag to add a new pattern that matches `$RUNTIME.exec($CMD, $ENVP, $ARG)` where `$CMD`, `$ENVP`, and `$ARG` are metavariables representing the command, environment variables, and the argument, respectively.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec($CMD, $ENVP, $ARG);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979905,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":736,\"prompt_tokens\":796,\"total_tokens\":1532,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987806265ccdfb1aa4d756c762a23f609eb7d365266a0\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the command and environment variables are passed as arrays. The current rule does not catch this case because it does not account for the scenario where `exec` is called with separate arrays for the command and environment variables. To address this, we need to add a new pattern that matches `Runtime.getRuntime().exec($CMD, $ENVP, $ARG)` where `$CMD` and `$ENVP` are arrays, and `$ARG` is a variable that could potentially be user-controlled.\\n\\nThe new pattern will be added under the `pattern-either` section to ensure that this case is covered.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: $RUNTIME.exec($CMD, $ENVP, $ARG);\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979901,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":716,\"prompt_tokens\":796,\"total_tokens\":1512,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878211b46138df3c550640e10333443fc2a98efd3113\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the command and environment variables are passed as arrays. The current rule does not capture this scenario because it lacks a pattern that matches `exec` calls with array arguments. To address this, we need to add a new pattern that matches `$RUNTIME.exec($CMD, $ENVP, $ARG)` where `$CMD` and `$ENVP` are arrays, and `$ARG` is a variable that could potentially be user-controlled.\\n\\nThe new pattern should be added to the `pattern-either` block to ensure that the rule correctly identifies this type of command injection vulnerability.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec($CMD, $ENVP, $ARG)'\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979903,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":714,\"prompt_tokens\":796,\"total_tokens\":1510,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798781430a2240b512b1216e229d168cab83c19444d0bd\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec` call with multiple arguments, including arrays of strings. The current rule does not capture this pattern because it lacks a specific pattern for handling `exec` calls with multiple array arguments. To address this, we need to add a new pattern that matches `Runtime.getRuntime().exec` calls where the first argument is an array of strings, the second argument is an array of strings, and the third argument is a variable or expression. This will ensure that the rule correctly identifies the command injection risk in the provided example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: $RUNTIME.exec($CMD, $ENVP, $ARG);\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":694,\"prompt_tokens\":796,\"total_tokens\":1490,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798781322de333aa60a045d0d9ee10c6c0c51091e9a35f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec(command, envp, input)` call where `command` is an array containing \\\"bash\\\" and `envp` is an array containing \\\"-c\\\". This is a potential command injection vulnerability because the `input` parameter could be user-controlled. The current rule does not catch this case because it does not account for the scenario where the command and environment parameters are passed as separate arrays.\\n\\nTo address this, we need to add a new pattern that matches `Runtime.getRuntime().exec($CMD, $ENVP, $ARG)` where `$CMD` is an array containing a shell command (e.g., \\\"bash\\\") and `$ENVP` is an array containing \\\"-c\\\". This will ensure that the rule correctly identifies this type of command injection vulnerability.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec($CMD, $ENVP, $ARG)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979902,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":746,\"prompt_tokens\":796,\"total_tokens\":1542,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798774541b41ddce50374106f9832e08fc27e0aac93841\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the command is passed as an array and additional arguments are provided. The current rule does not capture this scenario because it lacks a pattern that matches `Runtime.getRuntime().exec($CMD, $ARG1, $ARG2)`. To address this, we need to add a new pattern that captures this specific case.\\n\\nThe new pattern should match `$RUNTIME.exec($CMD, $ARG1, $ARG2)` where `$CMD` is a variable or array, and `$ARG1` and `$ARG2` are additional arguments. This will ensure that the rule correctly identifies the command injection risk in the false negative example.\\n\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec($CMD, $ARG1, $ARG2);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":725,\"prompt_tokens\":783,\"total_tokens\":1508,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979877519d573b8e8e652ef25def076aa41808b036970d0\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec` call where the command is passed as a `String[]` array, and the `\\\"-c\\\"` argument is directly provided as a separate parameter. The current rule does not catch this pattern because it only looks for cases where the command is concatenated or formatted, or where the command is explicitly a shell command like `bash` or `sh`. \\n\\nTo address this, we need to add a new pattern that matches cases where the command is passed as an array and the `\\\"-c\\\"` argument is directly provided. This can be done by adding a `pattern` that matches `$RUNTIME.exec($CMD, \\\"-c\\\", $ARG)` where `$CMD` is an array.\\n\\nThe new pattern will be:\\n```yaml\\n- pattern: '$RUNTIME.exec($CMD, \\\"-c\\\", $ARG)'\\n```\\n\\nThis pattern will catch the false negative example because it matches the structure of the `exec` call in the example, where `command` is an array and `\\\"-c\\\"` is directly provided as an argument.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: '$RUNTIME.exec($CMD, \\\"-c\\\", $ARG)'\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979908,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":805,\"prompt_tokens\":783,\"total_tokens\":1588,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782348d9dd0aac47988f4d3fe65a2570c112899b69b\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the first argument is a `String[]` array containing \\\"bash\\\", followed by \\\"-c\\\" and a user-controlled input. The current rule does not catch this because it lacks a pattern that matches `Runtime.getRuntime().exec($CMD, \\\"-c\\\", $ARG)` where `$CMD` is a `String[]` array containing a shell command. To fix this, we need to add a new pattern that matches this specific case. The new pattern should be added using the `pattern` tag to ensure it is included in the pattern-either block.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec($CMD, \\\"-c\\\", $ARG)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":707,\"prompt_tokens\":783,\"total_tokens\":1490,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987771055aa8e1a18ab51fc4adfd8dcf0d2a4d5d95e48\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec()` call where the first argument is an array of strings, and the second argument is a string. The current rule does not capture this pattern because it lacks a specific pattern to match this scenario. To address this, we need to add a new pattern that matches `$RUNTIME.exec($ARRAY, $STRING, ...)` where `$ARRAY` is an array of strings and `$STRING` is a string. This will ensure that the rule correctly identifies the command injection risk in the given example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - pattern: $RUNTIME.exec($ARRAY, $STRING, ...)\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979905,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":694,\"prompt_tokens\":783,\"total_tokens\":1477,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-formatted-runtime-call", "rule": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}\n\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n\n        public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n", "ground_truth": "rules:\n- id: command-injection-formatted-runtime-call\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: | \n            $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n        - pattern: |\n            $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n        - pattern: |\n            $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD,\"-c\",$ARG,...)\n            - pattern: |\n                $RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n            - pattern: |\n                $RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n          - pattern-inside: |\n              $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n              ...\n        - patterns:\n          - pattern-either:\n            - pattern: |\n                $RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n          - pattern-inside: |\n              $CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n              ...\n        - patterns:\n            - pattern-either:\n                - pattern: | \n                    $RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n                - pattern: |\n                    $RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n                - pattern: |\n                    $RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n            - pattern-inside: |\n                $BASH = new String[]{\"=~/(-c)/\", ...};\n                ...\n      - pattern-not-inside: |\n          $ARG = \"...\";\n          ...\n      - pattern-not: |\n          $RUNTIME.exec(\"...\",\"...\",\"...\",...)\n      - pattern-not: |\n          $RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n      - pattern-not: |\n          $RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n  message: >-\n    A formatted or concatenated string was detected as input to a java.lang.Runtime\n    call.\n    This is dangerous if a variable is controlled by user input and could result in\n    a\n    command injection. Ensure your variables are not controlled by users or sufficiently\n    sanitized.\n  metadata:\n    cwe:\n    - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.\n    category: security\n    technology:\n    - java\n    references:\n    - https://owasp.org/Top10/A03_2021-Injection\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - audit\n    likelihood: LOW\n    impact: HIGH\n    confidence: LOW\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/cf0a2b72/before/command-injection-formatted-runtime-call.yaml", "test_path": "extend_dataset/cf0a2b72/after/command-injection-formatted-runtime-call.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"/bin/sh -c some_tool\" + input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test1(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test2(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ruleid: command-injection-formatted-runtime-call\n        r.exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test3(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(String.format(\"%s.dll\", input));\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test4(String input) {\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", \"-c\", input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest(String input) {\n        Runtime r = Runtime.getRuntime();\n        // ok: command-injection-formatted-runtime-call\n        r.exec(\"echo 'blah'\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void okTest2(String input) {\n        // ok: command-injection-formatted-runtime-call\n        Runtime.getRuntime().loadLibrary(\"lib.dll\");\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(\"bash\", envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        String[] envp = new String[]{\"-c\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, envp, input);\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}"], "actual": [true, true, true, true, true, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, true, true, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-formatted-runtime-call\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\n    call. This poses a risk if user-controlled variables are involved, potentially\n    leading to command injection. Ensure variables are not user-controlled or properly\n    sanitized.\n  patterns:\n  - metavariable-pattern:\n      metavariable: $RUNTIME\n      patterns:\n      - pattern-either:\n        - pattern: (java.lang.Runtime $R)\n        - pattern: java.lang.Runtime.getRuntime(...)\n  - pattern-either:\n    - pattern: $RUNTIME.exec($X + $Y);\n    - pattern: $RUNTIME.exec(String.format(...));\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\n    - patterns:\n      - pattern-either:\n        - pattern: '$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern: '$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n            '\n        - pattern: '$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n            '\n        - patterns:\n          - pattern-either:\n            - pattern: '$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n\n                '\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n                '\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n                '\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n      - pattern-not-inside: '$ARG = \"...\";\n\n          ...\n\n          '\n      - pattern-not: '$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n\n          '\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n          '\n  severity: ERROR\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public void test6(String input) {\n        String[] command = new String[]{\"bash\"};\n        // ruleid: command-injection-formatted-runtime-call\n        Runtime.getRuntime().exec(command, \"-c\", input);\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878003ae4e096c2cc8de22d6661c1655d5c2bfad132d\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `Runtime.getRuntime().exec` call where the first argument is an array of strings (e.g., `command`), and the second argument is a string (e.g., `\\\"-c\\\"`). The current rule does not capture this specific pattern because it only checks for `exec` calls with concatenated strings or formatted strings, but not for cases where the first argument is an array and the second argument is a string.\\n\\nTo address this, we need to add a new pattern that matches `$RUNTIME.exec($ARRAY, \\\"-c\\\", $ARG)` where `$ARRAY` is an array of strings and `$ARG` is a variable that could be user-controlled. This will ensure that the rule correctly identifies the command injection risk in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-formatted-runtime-call\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a java.lang.Runtime\\n    call. This poses a risk if user-controlled variables are involved, potentially\\n    leading to command injection. Ensure variables are not user-controlled or properly\\n    sanitized.\\n  patterns:\\n  - metavariable-pattern:\\n      metavariable: $RUNTIME\\n      patterns:\\n      - pattern-either:\\n        - pattern: (java.lang.Runtime $R)\\n        - pattern: java.lang.Runtime.getRuntime(...)\\n  - pattern-either:\\n    - pattern: $RUNTIME.exec($X + $Y);\\n    - pattern: $RUNTIME.exec(String.format(...));\\n    - pattern: $RUNTIME.loadLibrary($X + $Y);\\n    - pattern: $RUNTIME.loadLibrary(String.format(...));\\n    - patterns:\\n      - pattern-either:\\n        - pattern: '$RUNTIME.exec(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec($ARRAY, \\\"-c\\\", $ARG,...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n            '\\n        - pattern: '$RUNTIME.exec(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n            '\\n        - patterns:\\n          - pattern-either:\\n            - pattern: '$RUNTIME.exec($CMD,\\\"-c\\\",$ARG,...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n                '\\n            - pattern: '$RUNTIME.exec(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n                '\\n          - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n              ...\\n\\n              '\\n      - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n          ...\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n          '\\n      - pattern-not: '$RUNTIME.exec(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n          '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979908,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":747,\"prompt_tokens\":783,\"total_tokens\":1530,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "weak-ssl-context", "rule": "rules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  severity: WARNING\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.0\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.1\");\n    }\n\n    public void test4() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.2\");\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "ground_truth": "rules:\n- id: weak-ssl-context\n  metadata:\n    cwe: 'CWE-326: Inadequate Encryption Strength'\n    owasp: 'A3: Sensitive Data Exposure'\n    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT\n    references:\n    - https://tools.ietf.org/html/rfc7568\n    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html\n  message: |\n    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions\n    are considered weak encryption and are deprecated.\n    Use SSLContext.getInstance(\"TLSv1.2\") for the best security.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLSv1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLSv1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLSv1.2\")\n", "rule_path": "extend_dataset/0533282b/before/weak-ssl-context.yaml", "test_path": "extend_dataset/0533282b/after/weak-ssl-context.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "actual": [true, true, true, true, true, true, true, false], "expected": [true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798780081b04abbdcb8df1a677225c44915993c9bd24d0\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a call to `SSLContext.getInstance(\\\"TLSv1.2\\\")`, which is actually a secure usage and should not be flagged by the rule. The current rule already has `pattern-not` clauses to exclude instances of `TLS1.2` and `TLS1.3`. However, the rule is still incorrectly flagging the example because it matches the general pattern `SSLContext.getInstance(\\\"...\\\")`.\\n\\nTo fix this, we can add a `pattern-not-inside` clause to exclude the entire method or class that contains the secure usage. This way, the rule will not flag any code inside a method or class that contains a secure `SSLContext.getInstance` call.\\n\\nIn this case, we can add a `pattern-not-inside` clause to exclude any code inside a method that contains `SSLContext.getInstance(\\\"TLSv1.2\\\")`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- fix-regex:\\n    regex: (.*?)\\\\.getInstance\\\\(.*?\\\\)\\n    replacement: \\\\1.getInstance(\\\"TLS1.2\\\")\\n  id: weak-ssl-context\\n  languages:\\n  - java\\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\\\"TLSv1.2\\\")\\n    for optimal security.\\n  patterns:\\n  - pattern-not: SSLContext.getInstance(\\\"TLS1.3\\\")\\n  - pattern-not: SSLContext.getInstance(\\\"TLS1.2\\\")\\n  - pattern: SSLContext.getInstance(\\\"...\\\")\\n  - pattern-not-inside: |\\n      public void $METHOD() {\\n        ...\\n        SSLContext.getInstance(\\\"TLSv1.2\\\");\\n        ...\\n      }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":395,\"prompt_tokens\":420,\"total_tokens\":815,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "weak-ssl-context", "rule": "rules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  severity: WARNING\n", "failed_tests": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "failed_type": "fp", "testsuite_a": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.0\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.1\");\n    }\n\n    public void test4() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.2\");\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test5() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "testsuite_b": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n}\n", "ground_truth": "rules:\n- id: weak-ssl-context\n  metadata:\n    cwe: 'CWE-326: Inadequate Encryption Strength'\n    owasp: 'A3: Sensitive Data Exposure'\n    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT\n    references:\n    - https://tools.ietf.org/html/rfc7568\n    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html\n  message: |\n    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions\n    are considered weak encryption and are deprecated.\n    Use SSLContext.getInstance(\"TLSv1.2\") for the best security.\n  severity: WARNING\n  languages: [java]\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLSv1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLSv1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLSv1.2\")\n", "rule_path": "extend_dataset/0533282b/before/weak-ssl-context.yaml", "test_path": "extend_dataset/0533282b/after/weak-ssl-context.java", "category": "historical", "splited_testsuite_b": ["import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test1() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test2() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test3() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test4() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"SSLv3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test5() {\n        // ruleid: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.1\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test6() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test8() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(getSslContext());\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}"], "actual": [true, true, true, true, true, true, true, false], "expected": [true, true, true, true, true, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nimport java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- fix-regex:\n    regex: (.*?)\\.getInstance\\(.*?\\)\n    replacement: \\1.getInstance(\"TLS1.2\")\n  id: weak-ssl-context\n  languages:\n  - java\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\"TLSv1.2\")\n    for optimal security.\n  patterns:\n  - pattern-not: SSLContext.getInstance(\"TLS1.3\")\n  - pattern-not: SSLContext.getInstance(\"TLS1.2\")\n  - pattern: SSLContext.getInstance(\"...\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "import java.lang.Runtime;\n\nclass Cls {\n\n    public Cls() {\n        System.out.println(\"Hello\");\n    }\n\n    public void test7() {\n        // ok: weak-ssl-context\n        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n    }\n\n    public String getSslContext() {\n        return \"Anything\";\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878197eaa0cb634d4956aa919b09d6d3507f5addc838\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example provided includes a call to `SSLContext.getInstance(\\\"TLSv1.3\\\")`, which is already correctly handled by the `pattern-not: SSLContext.getInstance(\\\"TLS1.3\\\")` pattern in the rule. However, the rule is still flagging this as a false positive, indicating that the rule might be too broad in its current form.\\n\\nTo ensure that the rule does not flag correct usage of `SSLContext.getInstance(\\\"TLSv1.3\\\")`, we can add a `pattern-not-inside` to exclude any method that does not involve SSLContext. Specifically, we can exclude methods that return a string, as in the `getSslContext` method in the false positive example. This will help to narrow down the scope of the rule to only methods that are likely to be setting up SSL contexts.\\n\\nWe will add a `pattern-not-inside` to exclude methods that return a string, ensuring that the rule does not flag methods like `getSslContext`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- fix-regex:\\n    regex: (.*?)\\\\.getInstance\\\\(.*?\\\\)\\n    replacement: \\\\1.getInstance(\\\"TLS1.2\\\")\\n  id: weak-ssl-context\\n  languages:\\n  - java\\n  message: An insecure SSL context was detected. TLS versions 1.0 and 1.1, along with\\n    all SSL versions, are deprecated due to weak encryption. Use SSLContext.getInstance(\\\"TLSv1.2\\\")\\n    for optimal security.\\n  patterns:\\n  - pattern-not: SSLContext.getInstance(\\\"TLS1.3\\\")\\n  - pattern-not: SSLContext.getInstance(\\\"TLS1.2\\\")\\n  - pattern: SSLContext.getInstance(\\\"...\\\")\\n  - pattern-not-inside: |\\n      public String $METHOD(...) {\\n        ...\\n      }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":406,\"prompt_tokens\":420,\"total_tokens\":826,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "incorrect": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878233b46138df3c550640e10333443fc2a98e2c968f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `String.format` call that is used to construct an exception message, not a SQL query. The current rule incorrectly flags this as a potential SQL injection vulnerability because the string contains SQL-like keywords (e.g., \\\"Update\\\"). To prevent this false positive, we can add a `pattern-not` to exclude cases where `String.format` is used in the context of throwing an exception. This way, the rule will ignore such cases and focus only on SQL string construction.\\n\\nThe pattern to be added should match the context where `String.format` is used within a `throw` statement. This will ensure that the rule does not flag legitimate exception messages as SQL injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-sql-string\\n  languages:\\n  - java\\n  message: '\\n\\n    User data should be inserted into SQL strings using prepared statements or an\\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\\n    or a secure library instead.\\n\\n    '\\n  mode: taint\\n  options:\\n    taint_assume_safe_booleans: true\\n    taint_assume_safe_numbers: true\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '\\\"$SQLSTR\\\" + ...\\n\\n          '\\n      - pattern: '\\\"$SQLSTR\\\".concat(...)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\\\"$SQLSTR\\\");\\n\\n            ...\\n\\n            '\\n        - pattern: $SB.append(...)\\n      - patterns:\\n        - pattern-inside: '$VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: $VAR += ...\\n      - pattern: String.format(\\\"$SQLSTR\\\", ...)\\n      - patterns:\\n        - pattern-inside: 'String $VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: String.format($VAR, ...)\\n    - pattern-not-inside: System.out.println(...)\\n    - pattern-not-inside: $LOG.info(...)\\n    - pattern-not-inside: $LOG.warn(...)\\n    - pattern-not-inside: $LOG.warning(...)\\n    - pattern-not-inside: $LOG.debug(...)\\n    - pattern-not: 'throw new ...(String.format(...))'\\n    - pattern-not-inside: $LOG.debugging(...)\\n    - pattern-not-inside: $LOG.error(...)\\n    - metavariable-regex:\\n        metavariable: $SQLSTR\\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\\\b\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - metavariable-regex:\\n        metavariable: $TYPE\\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\\n    - focus-metavariable: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979906,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":754,\"prompt_tokens\":985,\"total_tokens\":1739,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "incorrect": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798778928b7af1322b4712086cec2445c998af092a6d51\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `String.format` call that is used to construct an exception message, not a SQL query. The current rule incorrectly flags this as a potential SQL injection because it matches the `String.format` pattern and the string contains the word \\\"Update,\\\" which matches the regex for SQL operations.\\n\\nTo fix this, we can add a `pattern-not-inside` clause to exclude cases where `String.format` is used in the context of throwing an exception. This will prevent the rule from flagging such cases as potential SQL injections.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-sql-string\\n  languages:\\n  - java\\n  message: '\\n\\n    User data should be inserted into SQL strings using prepared statements or an\\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\\n    or a secure library instead.\\n\\n    '\\n  mode: taint\\n  options:\\n    taint_assume_safe_booleans: true\\n    taint_assume_safe_numbers: true\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '\\\"$SQLSTR\\\" + ...\\n\\n          '\\n      - pattern: '\\\"$SQLSTR\\\".concat(...)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\\\"$SQLSTR\\\");\\n\\n            ...\\n\\n            '\\n        - pattern: $SB.append(...)\\n      - patterns:\\n        - pattern-inside: '$VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: $VAR += ...\\n      - pattern: String.format(\\\"$SQLSTR\\\", ...)\\n      - patterns:\\n        - pattern-inside: 'String $VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: String.format($VAR, ...)\\n    - pattern-not-inside: System.out.println(...)\\n    - pattern-not-inside: $LOG.info(...)\\n    - pattern-not-inside: $LOG.warn(...)\\n    - pattern-not-inside: $LOG.warning(...)\\n    - pattern-not-inside: $LOG.debug(...)\\n    - pattern-not-inside: throw new Exception(String.format(...))\\n    - pattern-not-inside: $LOG.debugging(...)\\n    - pattern-not-inside: $LOG.error(...)\\n    - metavariable-regex:\\n        metavariable: $SQLSTR\\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\\\b\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - metavariable-regex:\\n        metavariable: $TYPE\\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\\n    - focus-metavariable: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979906,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":723,\"prompt_tokens\":985,\"total_tokens\":1708,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "incorrect": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979877784c038e14dcafb30bd771c014e08fe6accc14098\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `String.format` call that is used to construct an exception message, not a SQL query. The current rule incorrectly flags this as a potential SQL injection because the `String.format` pattern matches the `pattern-sinks` criteria. To prevent this false positive, we need to add a `pattern-not` clause that excludes `String.format` calls used in exception throwing contexts. Specifically, we can add a pattern that matches `throw new Exception(String.format(...))` and negate it using `pattern-not`.\\n\\nThis way, the rule will correctly classify the example as not being a SQL injection vulnerability.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-sql-string\\n  languages:\\n  - java\\n  message: '\\n\\n    User data should be inserted into SQL strings using prepared statements or an\\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\\n    or a secure library instead.\\n\\n    '\\n  mode: taint\\n  options:\\n    taint_assume_safe_booleans: true\\n    taint_assume_safe_numbers: true\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '\\\"$SQLSTR\\\" + ...\\n\\n          '\\n      - pattern: '\\\"$SQLSTR\\\".concat(...)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\\\"$SQLSTR\\\");\\n\\n            ...\\n\\n            '\\n        - pattern: $SB.append(...)\\n      - patterns:\\n        - pattern-inside: '$VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: $VAR += ...\\n      - pattern: String.format(\\\"$SQLSTR\\\", ...)\\n      - patterns:\\n        - pattern-inside: 'String $VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: String.format($VAR, ...)\\n    - pattern-not-inside: System.out.println(...)\\n    - pattern-not-inside: $LOG.info(...)\\n    - pattern-not-inside: $LOG.warn(...)\\n    - pattern-not-inside: $LOG.warning(...)\\n    - pattern-not-inside: $LOG.debug(...)\\n    - pattern-not: throw new Exception(String.format(...))\\n    - pattern-not-inside: $LOG.debugging(...)\\n    - pattern-not-inside: $LOG.error(...)\\n    - metavariable-regex:\\n        metavariable: $SQLSTR\\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\\\b\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - metavariable-regex:\\n        metavariable: $TYPE\\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\\n    - focus-metavariable: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":737,\"prompt_tokens\":985,\"total_tokens\":1722,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "incorrect": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878147f8c6c17fda21e54d5de19938bfdbdb5bdc27a8\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `String.format` call that does not construct a SQL query but rather formats an exception message. The current rule incorrectly flags this as a potential SQL injection vulnerability because it matches the `String.format` pattern. To exclude such cases, we can add a `pattern-not-inside` clause that ensures the `String.format` call is not inside a `throw` statement, which is typically used for exception handling and not for SQL query construction.\\n\\nThe new pattern will be:\\n```yaml\\npattern-not-inside: throw new Exception(String.format(...))\\n```\\n\\nThis pattern ensures that `String.format` calls used in exception messages are not flagged as potential SQL injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-sql-string\\n  languages:\\n  - java\\n  message: '\\n\\n    User data should be inserted into SQL strings using prepared statements or an\\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\\n    or a secure library instead.\\n\\n    '\\n  mode: taint\\n  options:\\n    taint_assume_safe_booleans: true\\n    taint_assume_safe_numbers: true\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '\\\"$SQLSTR\\\" + ...\\n\\n          '\\n      - pattern: '\\\"$SQLSTR\\\".concat(...)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\\\"$SQLSTR\\\");\\n\\n            ...\\n\\n            '\\n        - pattern: $SB.append(...)\\n      - patterns:\\n        - pattern-inside: '$VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: $VAR += ...\\n      - pattern: String.format(\\\"$SQLSTR\\\", ...)\\n      - patterns:\\n        - pattern-inside: 'String $VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: String.format($VAR, ...)\\n    - pattern-not-inside: System.out.println(...)\\n    - pattern-not-inside: $LOG.info(...)\\n    - pattern-not-inside: $LOG.warn(...)\\n    - pattern-not-inside: $LOG.warning(...)\\n    - pattern-not-inside: $LOG.debug(...)\\n    - pattern-not-inside: throw new Exception(String.format(...))\\n    - pattern-not-inside: $LOG.debugging(...)\\n    - pattern-not-inside: $LOG.error(...)\\n    - metavariable-regex:\\n        metavariable: $SQLSTR\\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\\\b\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - metavariable-regex:\\n        metavariable: $TYPE\\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\\n    - focus-metavariable: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979909,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":752,\"prompt_tokens\":985,\"total_tokens\":1737,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "tainted-sql-string", "rule": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "failed_tests": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "testsuite_b": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}\n\nclass Bar {\n  int x;\n\n  public int getX() {\n    return x;\n  }\n}\n\nclass Foo {\n  List<Bar> bars;\n\n  public List<Bar> getBars(String name) {\n    return bars;\n  }\n}\n\nclass Test {\n  @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok7(@RequestBody String name, Foo foo) {\n        var v = foo.getBars(name).get(0).getX();\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n  }\n}\n\n@Getter\n@Setter\npublic class SiteModel {\n\tprivate List<PrefixSiteIds> prefixes;\n    public List<PrefixSiteIds> getPrefixes(String name) {\n        return prefixes;\n    }\n}\n\n@Getter\n@Setter\npublic class PrefixSiteIds {\n\n\tpublic SiteIds sites;\n}\n@Getter\n@Setter\npublic class SiteIds {\n\tpublic Set<Integer> ids = new HashSet<>();\n}\n\nclass Test2 {\n  @RequestMapping(value = \"/testok8\", method = RequestMethod.POST, produces = \"plain/text\")\n  public ResultSet ok8(@RequestBody String name, SiteModel sitemodel) {\n        var v = sitemodel.getPrefixes(name).sites.ids.get(0);\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok in pro-engine\n        // ruleid: tainted-sql-string\n        sql += v + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n}\n", "ground_truth": "rules:\n  - id: tainted-sql-string-copy\n    languages:\n      - java\n    severity: ERROR\n    message: User data flows into this manually-constructed SQL string. User data\n      can be safely inserted into SQL strings using prepared statements or an\n      object-relational mapper (ORM). Manually-constructed SQL strings is a\n      possible indicator of SQL injection, which could let an attacker steal or\n      manipulate data from the database. Instead, use prepared statements\n      (`connection.PreparedStatement`) or a safe library.\n    metadata:\n      cwe:\n        - \"CWE-89: Improper Neutralization of Special Elements used in an SQL\n          Command ('SQL Injection')\"\n      owasp:\n        - A01:2017 - Injection\n        - A03:2021 - Injection\n      references:\n        - https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html\n      category: security\n      technology:\n        - spring\n      license: Commons Clause License Condition v1.0[LGPL-2.1-only]\n      cwe2022-top25: true\n      cwe2021-top25: true\n      subcategory:\n        - vuln\n      likelihood: HIGH\n      impact: MEDIUM\n      confidence: MEDIUM\n      interfile: true\n    options:\n      taint_assume_safe_numbers: true\n      taint_assume_safe_booleans: true\n    mode: taint\n    pattern-sources:\n      - patterns:\n          - pattern-either:\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n                    ...\n                  }\n          - metavariable-regex:\n              metavariable: $REQ\n              regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n          - metavariable-regex:\n              metavariable: $TYPE\n              regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n          - focus-metavariable: $SOURCE\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  \"$SQLSTR\" + ...\n              - pattern: |\n                  \"$SQLSTR\".concat(...)\n              - patterns:\n                  - pattern-inside: |\n                      StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n                      ...\n                  - pattern: $SB.append(...)\n              - patterns:\n                  - pattern-inside: |\n                      $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: $VAR += ...\n              - pattern: String.format(\"$SQLSTR\", ...)\n              - patterns:\n                  - pattern-inside: |\n                      String $VAR = \"$SQLSTR\";\n                      ...\n                  - pattern: String.format($VAR, ...)\n          - pattern-not-inside: System.out.println(...)\n          - pattern-not-inside: $LOG.info(...)\n          - pattern-not-inside: $LOG.warn(...)\n          - pattern-not-inside: $LOG.warning(...)\n          - pattern-not-inside: $LOG.debug(...)\n          - pattern-not-inside: $LOG.debugging(...)\n          - pattern-not-inside: $LOG.error(...)\n          - pattern-not-inside: new Exception(...)\n          - pattern-not-inside: throw ...;\n          - metavariable-regex:\n              metavariable: $SQLSTR\n              regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n", "rule_path": "extend_dataset/f59a4f07/before/tainted-sql-string.yaml", "test_path": "extend_dataset/f59a4f07/after/tainted-sql-string.java", "category": "historical", "splited_testsuite_b": ["package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test1(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = \" + name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test2(@RequestBody String name) {\n        // ruleid: tainted-sql-string\n        String sql = String.format(\"SELECT * FROM table WHERE name = %s;\", name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test3(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql.concat(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test4(@RequestBody String name) {\n        StringBuilder sql = new StringBuilder(\"SELECT * FROM table WHERE name = \");\n        // ruleid: tainted-sql-string\n        sql.append(name + \";\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql.toString());\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ruleid: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/ok1\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok1(@RequestBody String name) {\n        // ok: tainted-sql-string\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(String.format(\"Got request from %s\", name));\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "import java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        System.out.println(\"select noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n    @RequestMapping(value = \"/ok2\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok2(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = 'everyone';\";\n        // ok: tainted-sql-string\n        Logger.debug(\"Create noise for tests using tainted name:\" + name);\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok3\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok3(@RequestBody Integer name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok4\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok4(@RequestBody Boolean name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += name + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok5(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (name.substring(2,3) != \"hello\".substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}", "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/testok6\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet ok6(@RequestBody String name) {\n        String sql = \"SELECT * FROM table WHERE name = \";\n        // ok: tainted-sql-string\n        sql += (\"hello\".substring(2,3) == name.substring(2,3)) + \";\";\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:8080\", \"guest\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.execute(sql);\n        return rs;\n    }\n}"], "actual": [true, true, true, true, true, true, false, false, false, false, false, false, false, false], "expected": [true, true, true, true, true, false, false, false, false, false, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\npackage com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: tainted-sql-string\n  languages:\n  - java\n  message: '\n\n    User data should be inserted into SQL strings using prepared statements or an\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\n    or a secure library instead.\n\n    '\n  mode: taint\n  options:\n    taint_assume_safe_booleans: true\n    taint_assume_safe_numbers: true\n  pattern-sinks:\n  - patterns:\n    - pattern-either:\n      - pattern: '\"$SQLSTR\" + ...\n\n          '\n      - pattern: '\"$SQLSTR\".concat(...)\n\n          '\n      - patterns:\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n\n            ...\n\n            '\n        - pattern: $SB.append(...)\n      - patterns:\n        - pattern-inside: '$VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: $VAR += ...\n      - pattern: String.format(\"$SQLSTR\", ...)\n      - patterns:\n        - pattern-inside: 'String $VAR = \"$SQLSTR\";\n\n            ...\n\n            '\n        - pattern: String.format($VAR, ...)\n    - pattern-not-inside: System.out.println(...)\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not-inside: $LOG.info(...)\n    - pattern-not-inside: $LOG.warn(...)\n    - pattern-not-inside: $LOG.warning(...)\n    - pattern-not-inside: $LOG.debug(...)\n    - pattern-not-inside: $LOG.debugging(...)\n    - pattern-not-inside: $LOG.error(...)\n    - metavariable-regex:\n        metavariable: $SQLSTR\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\b\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern-inside: \"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\n  ...\\n\\\n          }\\n\"\n      - pattern-inside: \"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\n  ...\\n}\\n\"\n    - metavariable-regex:\n        metavariable: $REQ\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\n    - metavariable-regex:\n        metavariable: $TYPE\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\n    - focus-metavariable: $SOURCE\n  severity: ERROR\n", "incorrect": "package com.r2c.tests;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.autoconfigure.*;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n\n@RestController\n@EnableAutoConfiguration\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(value = \"/test5\", method = RequestMethod.POST, produces = \"plain/text\")\n    ResultSet test5(@RequestBody String name) {\n        try {\n            // ok: tainted-sql-string\n            throw new Exception(String.format(\"Update request from %s to %s isn't allowed\",\n            name, bar\n            ));\n        }\n        catch (NullPointerException e) {\n            System.out.println(\"Caught inside fun().\");\n            throw e; // rethrowing the exception\n        }\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878295eda9dd012fc70fe89489c2feb3062383b3ed9c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `String.format` call that is used to construct an exception message, not a SQL query. The current rule incorrectly flags this as a potential SQL injection because the `String.format` pattern matches, and the content of the string includes the word \\\"Update,\\\" which is a SQL keyword. To prevent this false positive, we can add a `pattern-not` to exclude cases where `String.format` is used to throw an exception. This way, the rule will not flag `String.format` calls that are part of exception handling.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: tainted-sql-string\\n  languages:\\n  - java\\n  message: '\\n\\n    User data should be inserted into SQL strings using prepared statements or an\\n    ORM. Manually constructing SQL strings can lead to SQL injection, allowing attackers\\n    to steal or manipulate data. Use prepared statements (`connection.PreparedStatement`)\\n    or a secure library instead.\\n\\n    '\\n  mode: taint\\n  options:\\n    taint_assume_safe_booleans: true\\n    taint_assume_safe_numbers: true\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '\\\"$SQLSTR\\\" + ...\\n\\n          '\\n      - pattern: '\\\"$SQLSTR\\\".concat(...)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: 'StringBuilder $SB = new StringBuilder(\\\"$SQLSTR\\\");\\n\\n            ...\\n\\n            '\\n        - pattern: $SB.append(...)\\n      - patterns:\\n        - pattern-inside: '$VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: $VAR += ...\\n      - pattern: String.format(\\\"$SQLSTR\\\", ...)\\n      - patterns:\\n        - pattern-inside: 'String $VAR = \\\"$SQLSTR\\\";\\n\\n            ...\\n\\n            '\\n        - pattern: String.format($VAR, ...)\\n    - pattern-not-inside: System.out.println(...)\\n    - pattern-not: throw new Exception(String.format(\\\"$SQLSTR\\\", ...))\\n    - pattern-not-inside: $LOG.info(...)\\n    - pattern-not-inside: $LOG.warn(...)\\n    - pattern-not-inside: $LOG.warning(...)\\n    - pattern-not-inside: $LOG.debug(...)\\n    - pattern-not-inside: $LOG.debugging(...)\\n    - pattern-not-inside: $LOG.error(...)\\n    - metavariable-regex:\\n        metavariable: $SQLSTR\\n        regex: (?i)(select|delete|insert|create|update|alter|drop)\\\\b\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\\\\n  ...\\\\n\\\\\\n          }\\\\n\\\"\\n      - pattern-inside: \\\"$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\\\\n  ...\\\\n}\\\\n\\\"\\n    - metavariable-regex:\\n        metavariable: $REQ\\n        regex: (RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)\\n    - metavariable-regex:\\n        metavariable: $TYPE\\n        regex: ^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))\\n    - focus-metavariable: $SOURCE\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979904,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":728,\"prompt_tokens\":985,\"total_tokens\":1713,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "desede-is-deprecated", "rule": "rules:\n- id: desede-is-deprecated\n  languages:\n  - java\n  - kt\n  message: Triple DES (3DES or DESede) is deprecated. Use AES instead. For details,\n    visit https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA.\n  pattern: $CIPHER.getInstance(\"=~/DESede.*/\")\n  severity: WARNING\n", "failed_tests": ["/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}"], "failed_type": "fp", "testsuite_a": "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}\n", "testsuite_b": "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}\n\n/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}\n\n", "ground_truth": "rules:\n  - id: desede-is-deprecated\n    message: >-\n      Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher.\n      Upgrade to use AES.\n    metadata:\n      cwe: \"CWE-326: Inadequate Encryption Strength\"\n      owasp: \"A3: Sensitive Data Exposure\"\n      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n      asvs:\n        section: V6 Stored Cryptography Verification Requirements\n        control_id: 6.2.5 Insecure Algorithm\n        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms\n      references:\n        - https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA\n      category: security\n      technology:\n        - java\n    severity: WARNING\n    patterns: \n    - pattern-either: \n      - pattern: |\n          $CIPHER.getInstance(\"=~/DESede.*/\")\n      - pattern: |\n          $CRYPTO.KeyGenerator.getInstance(\"DES\")\n    languages:\n      - java\n      - kt\n", "rule_path": "extend_dataset/a7dd64af/before/desede-is-deprecated.yaml", "test_path": "extend_dataset/a7dd64af/after/desede-is-deprecated.java", "category": "historical", "splited_testsuite_b": ["package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    // cf. https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE\n    protected void danger(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ruleid: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}", "package servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class Cls extends HttpServlet\n{\n    private static org.apache.log4j.Logger log = Logger.getLogger(Register.class);\n\n    protected void ok(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ok: desede-is-deprecated\n        Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        c.init(Cipher.ENCRYPT_MODE, k, iv);\n        byte[] cipherText = c.doFinal(plainText);\n    }\n}", "/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}"], "actual": [true, false, false], "expected": [true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: desede-is-deprecated\n  languages:\n  - java\n  - kt\n  message: Triple DES (3DES or DESede) is deprecated. Use AES instead. For details,\n    visit https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA.\n  pattern-either:\n  - pattern: $CIPHER.getInstance(\"=~/DESede.*/\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: desede-is-deprecated\n  languages:\n  - java\n  - kt\n  message: Triple DES (3DES or DESede) is deprecated. Use AES instead. For details,\n    visit https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA.\n  pattern-either:\n  - pattern: $CIPHER.getInstance(\"=~/DESede.*/\")\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "/**\n * OWASP Benchmark v1.2\n *\n * <p>This file is part of the Open Web Application Security Project (OWASP) Benchmark Project. For\n * details, please see <a\n * href=\"https://owasp.org/www-project-benchmark/\">https://owasp.org/www-project-benchmark/</a>.\n *\n * <p>The OWASP Benchmark is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation, version 2.\n *\n * <p>The OWASP Benchmark is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE. See the GNU General Public License for more details.\n *\n * @author Dave Wichers\n * @created 2015\n */\n@WebServlet(value = \"/crypto-00/BenchmarkTest00019\")\npublic class BenchmarkTest00019 extends HttpServlet {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        java.io.InputStream param = request.getInputStream();\n\n        try {\n            java.util.Properties benchmarkprops = new java.util.Properties();\n            benchmarkprops.load(\n                    this.getClass().getClassLoader().getResourceAsStream(\"benchmark.properties\"));\n            String algorithm = benchmarkprops.getProperty(\"cryptoAlg1\", \"DESede/ECB/PKCS5Padding\");\n            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(algorithm);\n\n            // Prepare the cipher to encrypt\n            // ruleid: desede-is-deprecated\n            javax.crypto.SecretKey key = javax.crypto.KeyGenerator.getInstance(\"DES\").generateKey();\n            c.init(javax.crypto.Cipher.ENCRYPT_MODE, key);\n\n            // encrypt and store the results\n            byte[] input = {(byte) '?'};\n            Object inputParam = param;\n            if (inputParam instanceof String) input = ((String) inputParam).getBytes();\n            if (inputParam instanceof java.io.InputStream) {\n                byte[] strInput = new byte[1000];\n                int i = ((java.io.InputStream) inputParam).read(strInput);\n                if (i == -1) {\n                    response.getWriter()\n                            .println(\n                                    \"This input source requires a POST, not a GET. Incompatible UI for the InputStream source.\");\n                    return;\n                }\n                input = java.util.Arrays.copyOf(strInput, i);\n            }\n            byte[] result = c.doFinal(input);\n\n            java.io.File fileTarget =\n                    new java.io.File(\n                            new java.io.File(org.owasp.benchmark.helpers.Utils.TESTFILES_DIR),\n                            \"passwordFile.txt\");\n            java.io.FileWriter fw =\n                    new java.io.FileWriter(fileTarget, true); // the true will append the new data\n            fw.write(\n                    \"secret_value=\"\n                            + org.owasp.esapi.ESAPI.encoder().encodeForBase64(result, true)\n                            + \"\\n\");\n            fw.close();\n            response.getWriter()\n                    .println(\n                            \"Sensitive value: '\"\n                                    + org.owasp\n                                            .esapi\n                                            .ESAPI\n                                            .encoder()\n                                            .encodeForHTML(new String(input))\n                                    + \"' encrypted and stored<br/>\");\n\n        } catch (java.security.NoSuchAlgorithmException\n                | javax.crypto.NoSuchPaddingException\n                | javax.crypto.IllegalBlockSizeException\n                | javax.crypto.BadPaddingException\n                | java.security.InvalidKeyException e) {\n            response.getWriter()\n                    .println(\n                            \"Problem executing crypto - javax.crypto.Cipher.getInstance(java.lang.String,java.security.Provider) Test Case\");\n            e.printStackTrace(response.getWriter());\n            throw new ServletException(e);\n        }\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987772030a3cfcb7f13a212b89b96cf3c30cef2272cd2\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example uses `Cipher.getInstance(algorithm)` where the algorithm is loaded from a properties file with the default value \\\"DESede/ECB/PKCS5Padding\\\". The current rule only catches direct string literals like `Cipher.getInstance(\\\"DESede/ECB/PKCS5Padding\\\")`. To catch cases where the algorithm is loaded from a variable or property, we need to add a pattern that matches `Cipher.getInstance($ALGORITHM)` and then use a `pattern-regex` to check if the variable contains \\\"DESede\\\". This will ensure that the rule catches both direct string literals and variables that contain the deprecated algorithm.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: desede-is-deprecated\\n  languages:\\n  - java\\n  - kt\\n  message: Triple DES (3DES or DESede) is deprecated. Use AES instead. For details,\\n    visit https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA.\\n  pattern-either:\\n  - pattern: $CIPHER.getInstance(\\\"=~/DESede.*/\\\")\\n  - pattern: $CIPHER.getInstance($ALGORITHM)\\n    pattern-regex: DESede\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979888,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":293,\"prompt_tokens\":1178,\"total_tokens\":1471,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-either:\n      - pattern-not: '$PB.command(\"...\",...)\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-either:\n      - pattern-not: '$PB.command(\"...\",...)\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782455bada34a84de39d8934d9706b7b4a520c65c2c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a user-controlled input (`userInput`). The current rule does not catch this because it lacks a pattern that specifically matches cases where the `command` method is called with a hardcoded string followed by a user-controlled input. To address this, we need to add a `pattern-not` that excludes cases where the `command` method is called with a hardcoded string followed by a user-controlled input. This will ensure that the rule correctly identifies such cases as potential command injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n- pattern-not: '$PB.command(\\\"cmd\\\", \\\"/c\\\", $ARG,...)'\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979885,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":166,\"prompt_tokens\":1276,\"total_tokens\":1442,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979878117af3d860f181fcba7f252ea2d6bc1813a41fe77\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled input (`userInput`). The current rule does not catch this case because it lacks a pattern that specifically matches the scenario where the `command` method is called with a hardcoded string followed by a variable that could be user-controlled. \\n\\nTo address this, we need to add a `pattern` that matches the `builder.command(\\\"cmd\\\", \\\"/c\\\", $ARG)` structure, where `$ARG` is a variable that could be user-controlled. This will ensure that the rule correctly identifies the command injection vulnerability in the example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-process-builder\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\\n    which can be dangerous if user-controlled and lead to command injection. Ensure\\n    variables are not user-controlled or properly sanitized.\\n  pattern-either:\\n  - patterns:\\n    - pattern: 'new ProcessBuilder($CMD,...)\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern: '$PB.command($CMD,...)\\n\\n        '\\n    - pattern: '$PB.command(\\\"cmd\\\", \\\"/c\\\", $ARG,...)\\n\\n        '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-not: '$PB.command(\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: 'new ProcessBuilder(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: 'new ProcessBuilder($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '$PB.command(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: '$PB.command(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: '$PB.command(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: '$PB.command($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: '$PB.command(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: '$PB.command(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: '$PB.command(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979924,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":1202,\"prompt_tokens\":1270,\"total_tokens\":2472,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979877942945ada8e478a29a2419a74b62ea1111099590a\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled argument (`userInput`). The current rule does not catch this case because it lacks a pattern that matches the `command` method being called with a string literal and a variable argument. Specifically, the rule needs to account for cases where the command is a string literal (like `\\\"cmd\\\"`) and the subsequent argument is a variable (like `userInput`).\\n\\nTo address this, we can add a `pattern-inside` clause that matches the scenario where `$CMD` is a string literal and `$ARG` is a variable. This will ensure that the rule correctly identifies the potential command injection vulnerability in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n- pattern-inside: '$CMD = \\\"cmd\\\"; $ARG = $USER_INPUT;\\n\\n        ...\\n\\n        '\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979885,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":205,\"prompt_tokens\":1276,\"total_tokens\":1481,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"0217399798780746f186e6bcb2843e7d2dcfbc6d9f87b2272ebd4\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled argument (`userInput`). The current rule does not catch this because it lacks a pattern to detect cases where the command is directly passed as arguments without being part of a list or array. To address this, we need to add a pattern that matches the `command` method call with a variable argument that could be user-controlled.\\n\\nWe will add a `pattern-inside` clause to capture cases where the `command` method is called with a variable argument, which could be user-controlled. This will ensure that the rule correctly identifies such cases as potential command injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\npattern-inside: '$CMD = $USER_INPUT;\\n\\n    ...\\n\\n    '\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979887,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":183,\"prompt_tokens\":1276,\"total_tokens\":1459,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/814eea4b/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/814eea4b/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979878176b86754b3c539403629bde052ca1292b61c9f59\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled argument (`userInput`). The current rule does not catch this case because it does not account for the scenario where the command is constructed with a hardcoded string like `\\\"cmd\\\"` followed by a user-controlled argument.\\n\\nTo address this, we need to add a pattern that matches when the `command` method is called with a hardcoded string like `\\\"cmd\\\"` followed by a user-controlled argument. This can be achieved by adding a `pattern-inside` that matches the specific sequence of arguments in the `command` method call.\\n\\nThe new pattern should be added to the `pattern-either` block under the `patterns` section where the `$PB.command(...)` patterns are defined. This will ensure that the rule catches cases where `\\\"cmd\\\"` is used in conjunction with a user-controlled argument.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n    - pattern-inside: '$PB.command(\\\"cmd\\\", \\\"/c\\\", $ARG,...);\\n        ...\\n        '\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979890,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":244,\"prompt_tokens\":1276,\"total_tokens\":1520,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "disallow-old-tls-versions1", "rule": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "failed_tests": ["class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n", "testsuite_b": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n", "ground_truth": "rules:\n- id: disallow-old-tls-versions1\n  message: >-\n    Detects direct creations of SSLConnectionSocketFactories that don't disallow SSL v2, SSL v3, and TLS\n    v1.\n    SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of trusted\n    certificates.\n    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages: [java]\n  patterns:\n  - pattern: |\n      new SSLConnectionSocketFactory(...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_2). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_3). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n", "rule_path": "extend_dataset/fc9ff9a4/before/disallow-old-tls-versions1.yaml", "test_path": "extend_dataset/fc9ff9a4/after/disallow-old-tls-versions1.java", "category": "historical", "splited_testsuite_b": ["class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "actual": [true, true, true, false, false, false, true], "expected": [true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nclass Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"02173997987800246deda5a0dbf9f46f8e602560670b511cc79bd\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the creation of an `SSLConnectionSocketFactory` with a custom `SSLContext`, but it also sets the supported protocols to `TLS.V_1_3` via `TlsConfig`. This means that the example is actually secure and should not be flagged by the rule. To prevent this false positive, we need to add a `pattern-not-inside` clause that excludes cases where `TlsConfig` is used to set the supported protocols to `TLSv1.3`.\\n\\nThe `pattern-not-inside` clause will look for the presence of `TlsConfig.custom().setSupportedProtocols(TLS.V_1_3)` in the surrounding code, ensuring that such secure configurations are not flagged.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: disallow-old-tls-versions1\\n  languages:\\n  - java\\n  message: '\\n\\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\\n    man-in-the-middle attacks, and other vulnerabilities.\\n\\n    '\\n  patterns:\\n  - pattern: 'new SSLConnectionSocketFactory(...);\\n\\n      '\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\", \\\"TLSv1.3\\\"},\\n      ...);\\n\\n      '\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\", \\\"TLSv1.2\\\"},\\n      ...);\\n\\n      '\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\"}, ...);\\n\\n      '\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\"}, ...);\\n\\n      '\\n  - pattern-not-inside: |\\n      TlsConfig.custom().setSupportedProtocols(TLS.V_1_3).build();\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979893,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":458,\"prompt_tokens\":672,\"total_tokens\":1130,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "disallow-old-tls-versions1", "rule": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "failed_tests": ["class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n", "testsuite_b": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n", "ground_truth": "rules:\n- id: disallow-old-tls-versions1\n  message: >-\n    Detects direct creations of SSLConnectionSocketFactories that don't disallow SSL v2, SSL v3, and TLS\n    v1.\n    SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of trusted\n    certificates.\n    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages: [java]\n  patterns:\n  - pattern: |\n      new SSLConnectionSocketFactory(...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_2). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_3). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n", "rule_path": "extend_dataset/fc9ff9a4/before/disallow-old-tls-versions1.yaml", "test_path": "extend_dataset/fc9ff9a4/after/disallow-old-tls-versions1.java", "category": "historical", "splited_testsuite_b": ["class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "actual": [true, true, true, false, false, false, true], "expected": [true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nclass Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "incorrect": "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"021739979878168f942e386849eac873461595dafd0b135cdd8c1\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example is correctly using TLS v1.3, but the rule is flagging it because it doesn't explicitly check for the presence of `TlsConfig` with `setSupportedProtocols(TLS.V_1_3)`. To fix this, we need to add a `pattern-not-inside` clause that excludes cases where `TlsConfig` is configured with `TLS.V_1_3`. This will ensure that the rule does not flag instances where TLS v1.3 is explicitly enabled via `TlsConfig`.\\n\\nThe new pattern should look for the presence of `TlsConfig` with `setSupportedProtocols(TLS.V_1_3)` and exclude those cases from being flagged.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: disallow-old-tls-versions1\\n  languages:\\n  - java\\n  message: '\\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\\n    man-in-the-middle attacks, and other vulnerabilities.\\n    '\\n  patterns:\\n  - pattern: 'new SSLConnectionSocketFactory(...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\", \\\"TLSv1.3\\\"}, ...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\", \\\"TLSv1.2\\\"}, ...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\"}, ...);'\\n  - pattern-not-inside: |\\n      TlsConfig tlsConfig = TlsConfig.custom().setSupportedProtocols(TLS.V_1_3).build();\\n      ...\\n      PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory($CSF).setDefaultTlsConfig(tlsConfig).build();\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\"}, ...);'\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979896,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":486,\"prompt_tokens\":672,\"total_tokens\":1158,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "disallow-old-tls-versions1", "rule": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "failed_tests": ["class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "failed_type": "fp", "testsuite_a": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n", "testsuite_b": "class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}\n\nclass Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n", "ground_truth": "rules:\n- id: disallow-old-tls-versions1\n  message: >-\n    Detects direct creations of SSLConnectionSocketFactories that don't disallow SSL v2, SSL v3, and TLS\n    v1.\n    SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of trusted\n    certificates.\n    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.\n  severity: WARNING\n  metadata:\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n    category: security\n    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'\n    owasp: 'A03:2017 - Sensitive Data Exposure'\n    references:\n    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle\n    subcategory:\n    - vuln\n    technology:\n    - java\n    vulnerability: Insecure Transport\n  languages: [java]\n  patterns:\n  - pattern: |\n      new SSLConnectionSocketFactory(...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n  - pattern-not: |\n      new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_2). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n  - pattern-not-inside: >\n      (SSLConnectionSocketFactory $SF) = new\n      SSLConnectionSocketFactory(...);\n      ...\n      (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_3). ... .build();\n      ...\n      HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n", "rule_path": "extend_dataset/fc9ff9a4/before/disallow-old-tls-versions1.yaml", "test_path": "extend_dataset/fc9ff9a4/after/disallow-old-tls-versions1.java", "category": "historical", "splited_testsuite_b": ["class Bad {\n    public void bad_disable_old_tls1() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Bad {\n    public void bad_disable_old_tls2() {\n        //ruleid: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1\", \"TLSv1.1\", \"SSLv3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls1() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls2() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls3() {\n        //ok: disallow-old-tls-versions1\n        SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(\n                sslContext,\n                new String[] {\"TLSv1.3\"},\n                null,\n                SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n    }\n}", "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}"], "actual": [true, true, true, false, false, false, true], "expected": [true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n\n```\nThe false positive example is as follows:\n```java\nclass Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: disallow-old-tls-versions1\n  languages:\n  - java\n  message: '\n\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\n    man-in-the-middle attacks, and other vulnerabilities.\n\n    '\n  patterns:\n  - pattern: 'new SSLConnectionSocketFactory(...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"},\n      ...);\n\n      '\n  - <PATTERN>: <GENERATE A PATTERN HERE>\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"},\n      ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n\n      '\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n\n      '\n  severity: WARNING\n", "incorrect": "class Ok {\n    public void ok_disable_old_tls4() {\n            TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -> true;\n\t\t\tSSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();\n            //ok: disallow-old-tls-versions1\n\t\t\tSSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n\t\t\tTlsConfig tlsConfig = TlsConfig.custom().setHandshakeTimeout(Timeout.ofSeconds(30)).setSupportedProtocols(TLS.V_1_3).build();\n\t\t\tHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory(csf).setDefaultTlsConfig(tlsConfig).build();\n\t\t\tCloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n\t\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n\t\t\trequestFactory.setHttpClient(httpClient);\n\t\t\trestTemplate = new RestTemplate(requestFactory);\n    }\n}", "type": "fp"}, "response": "{\"id\":\"0217399798781157549dffca8895f14e3c2bdf728d3ba381bb073\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves the creation of an `SSLConnectionSocketFactory` with an `SSLContext` but without specifying the supported protocols directly in the constructor. However, the example then sets the supported protocols using `TlsConfig` with `TLS.V_1_3`, which is a secure configuration. To avoid flagging this as a violation, we need to add a pattern that excludes cases where the `SSLConnectionSocketFactory` is created with an `SSLContext` and the supported protocols are set later in a secure manner. The appropriate pattern tag to use here is `pattern-not-inside`, which will exclude the entire context where the secure configuration is applied.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: disallow-old-tls-versions1\\n  languages:\\n  - java\\n  message: '\\n    Detects direct creations of SSLConnectionSocketFactories that do not disallow\\n    SSL v2, SSL v3, and TLS v1. SSLSocketFactory can validate the HTTPS server''s\\n    identity against trusted certificates. These protocols are deprecated due to POODLE,\\n    man-in-the-middle attacks, and other vulnerabilities.\\n    '\\n  patterns:\\n  - pattern: 'new SSLConnectionSocketFactory(...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\", \\\"TLSv1.3\\\"}, ...);'\\n  - pattern-not-inside: |\\n      SSLConnectionSocketFactory $CSF = new SSLConnectionSocketFactory($SSL_CONTEXT);\\n      ...\\n      TlsConfig $TLS_CONFIG = TlsConfig.custom().setSupportedProtocols($PROTOCOLS).build();\\n      ...\\n      HttpClientConnectionManager $CM = PoolingHttpClientConnectionManagerBuilder.create().setSSLSocketFactory($CSF).setDefaultTlsConfig($TLS_CONFIG).build();\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\", \\\"TLSv1.2\\\"}, ...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.3\\\"}, ...);'\\n  - pattern-not: 'new SSLConnectionSocketFactory(..., new String[] {\\\"TLSv1.2\\\"}, ...);'\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979897,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":502,\"prompt_tokens\":672,\"total_tokens\":1174,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-either:\n      - pattern-not: '$PB.command(\"...\",...)\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-either:\n      - pattern-not: '$PB.command(\"...\",...)\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979877930e44369f60a4697a1e5b969a50230c0ed61fb7b\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a user-controlled input (`userInput`). The current rule does not catch this case because it does not account for the scenario where the command is directly passed as arguments to the `command` method without being wrapped in a list or array. \\n\\nTo address this, we need to add a `pattern-not` to exclude cases where the command is directly passed as a string literal or a safe array/list, but still catch cases where user-controlled input is used. Specifically, we should add a `pattern-not` to exclude the case where the command is a safe string literal or array/list.\\n\\nWe will add the following pattern to the `pattern-either` section under the second `patterns` block:\\n```yaml\\n- pattern-not: '$PB.command(\\\"...\\\", \\\"...\\\", \\\"...\\\", ...)'\\n```\\n\\nThis pattern will ensure that the rule does not flag cases where the command arguments are hardcoded string literals, but will still catch cases where user-controlled input is used, such as in the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-process-builder\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\\n    which can be dangerous if user-controlled and lead to command injection. Ensure\\n    variables are not user-controlled or properly sanitized.\\n  pattern-either:\\n  - patterns:\\n    - pattern: 'new ProcessBuilder($CMD,...)\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern: '$PB.command($CMD,...)\\n\\n        '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-either:\\n      - pattern-not: '$PB.command(\\\"...\\\",...)\\n\\n          '\\n      - pattern-not: '$PB.command(\\\"...\\\", \\\"...\\\", \\\"...\\\", ...)\\n\\n          '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: 'new ProcessBuilder(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: 'new ProcessBuilder($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '$PB.command(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: '$PB.command(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: '$PB.command(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: '$PB.command($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: '$PB.command(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: '$PB.command(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: '$PB.command(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979929,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":1301,\"prompt_tokens\":1276,\"total_tokens\":2577,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979878105ed480b78fd6eef2badfc7bcc496ff9e3326a7c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled input (`userInput`). The current rule does not catch this case because it lacks a pattern that specifically matches the `builder.command(\\\"cmd\\\", \\\"/c\\\", $ARG)` structure, where `$ARG` is a variable that could be user-controlled.\\n\\nTo address this, we need to add a new pattern that matches the `builder.command(\\\"cmd\\\", \\\"/c\\\", $ARG)` structure. This pattern should be placed in the second `patterns` block under the `pattern-inside` constraint to ensure it only matches within the context of a `ProcessBuilder` instance. This will allow the rule to correctly identify and flag the command injection vulnerability in the example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: command-injection-process-builder\\n  languages:\\n  - java\\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\\n    which can be dangerous if user-controlled and lead to command injection. Ensure\\n    variables are not user-controlled or properly sanitized.\\n  pattern-either:\\n  - patterns:\\n    - pattern: 'new ProcessBuilder($CMD,...)\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern: '$PB.command($CMD,...)\\n\\n        '\\n    - pattern: '$PB.command(\\\"cmd\\\", \\\"/c\\\", $ARG)\\n\\n        '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = Arrays.asList(\\\"...\\\",...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$CMD = new String[]{\\\"...\\\",...};\\n\\n        ...\\n\\n        '\\n    - pattern-not: '$PB.command(\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: 'new ProcessBuilder(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: 'new ProcessBuilder(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: 'new ProcessBuilder($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '$PB.command(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...)\\n\\n          '\\n      - pattern: '$PB.command(Arrays.asList(\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...),...)\\n\\n          '\\n      - pattern: '$PB.command(new String[]{\\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\",\\\"-c\\\",$ARG,...},...)\\n\\n          '\\n      - patterns:\\n        - pattern-either:\\n          - pattern: '$PB.command($CMD,\\\"-c\\\",$ARG,...)\\n\\n              '\\n          - pattern: '$PB.command(Arrays.asList($CMD,\\\"-c\\\",$ARG,...),...)\\n\\n              '\\n          - pattern: '$PB.command(new String[]{$CMD,\\\"-c\\\",$ARG,...},...)\\n\\n              '\\n        - pattern-inside: '$CMD = \\\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\\\";\\n\\n            ...\\n\\n            '\\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\\n\\n        ...\\n\\n        '\\n    - pattern-not-inside: '$ARG = \\\"...\\\";\\n\\n        ...\\n\\n        '\\n    - pattern-not: '$PB.command(\\\"...\\\",\\\"...\\\",\\\"...\\\",...)\\n\\n        '\\n    - pattern-not: '$PB.command(new String[]{\\\"...\\\",\\\"...\\\",\\\"...\\\",...},...)\\n\\n        '\\n    - pattern-not: '$PB.command(Arrays.asList(\\\"...\\\",\\\"...\\\",\\\"...\\\",...),...)\\n\\n        '\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979923,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":1226,\"prompt_tokens\":1270,\"total_tokens\":2496,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"021739979877382af3d860f181fcba7f252ea2d6bc1813a6cb9e7\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a potentially user-controlled input (`userInput`). The current rule does not catch this because it lacks a pattern to match cases where the command is directly passed as arguments without being part of a list or array. To address this, we need to add a `pattern-inside` clause that matches the scenario where the command is directly passed as arguments to the `command` method.\\n\\nThe new pattern should ensure that the rule catches cases where the command is directly passed as arguments, such as `builder.command(\\\"cmd\\\", \\\"/c\\\", userInput)`. This will help the rule correctly classify the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n- pattern-inside: |\\n    $TYPE $PB = new ProcessBuilder(...);\\n    ...\\n    $PB.command($CMD, $ARG1, $ARG2, ...);\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979885,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":207,\"prompt_tokens\":1276,\"total_tokens\":1483,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"02173997987810549e22a4e9df546c6396d0d79c349b9dbdd87d3\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a string array that includes a user-controlled input (`userInput`). The current rule does not catch this case because it does not account for the scenario where `$CMD` is a variable that could be user-controlled. To address this, we need to add a `pattern-inside` that matches when `$CMD` is a variable that could potentially be user-controlled. This will ensure that the rule correctly identifies such cases as potential command injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n- pattern-inside: '$CMD = $VAR;\\n\\n    ...\\n\\n    '\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979885,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":155,\"prompt_tokens\":1276,\"total_tokens\":1431,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "command-injection-process-builder", "rule": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "failed_tests": ["public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}"], "failed_type": "fp", "testsuite_a": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", \"ls\");\n      return \"foo\";\n    }\n\n}\n", "testsuite_b": "public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n\n}\n", "ground_truth": "rules:\n  - id: command-injection-process-builder\n    pattern-either:\n      - patterns:\n          - pattern: |\n              new ProcessBuilder($CMD,...)\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern: |\n              $PB.command($CMD,...)\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $CMD = \"...\";\n              ...\n          - pattern-not-inside: |\n              $CMD = Arrays.asList(\"...\",...);\n              ...\n          - pattern-not-inside: |\n              $CMD = new String[]{\"...\",...};\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          new ProcessBuilder($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              new ProcessBuilder(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n      - patterns:\n          - pattern-either:\n              - pattern: |\n                  $PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n              - pattern: |\n                  $PB.command(\"cmd\",\"/c\",$ARG,...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n              - pattern: |\n                  $PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n              - pattern: |\n                  $PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"-c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n                      ...\n              - patterns:\n                  - pattern-either:\n                      - pattern: |\n                          $PB.command($CMD,\"/c\",$ARG,...)\n                      - pattern: |\n                          $PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n                      - pattern: |\n                          $PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n                  - pattern-inside: |\n                      $CMD = \"cmd\";\n                      ...\n          - pattern-inside: |\n              $TYPE $PB = new ProcessBuilder(...);\n              ...\n          - pattern-not-inside: |\n              $ARG = \"...\";\n              ...\n          - pattern-not: |\n              $PB.command(\"...\",\"...\",\"...\",...)\n          - pattern-not: |\n              $PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n          - pattern-not: |\n              $PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n    message: >-\n      A formatted or concatenated string was detected as input to a ProcessBuilder call.\n      This is dangerous if a variable is controlled by user input and could result in\n      a\n      command injection. Ensure your variables are not controlled by users or sufficiently\n      sanitized.\n    metadata:\n      cwe: \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n      owasp: \"A1: Injection\"\n      category: security\n      technology:\n        - java\n    severity: ERROR\n    languages:\n      - java\n", "rule_path": "extend_dataset/4268dee5/before/command-injection-process-builder.yaml", "test_path": "extend_dataset/4268dee5/after/command-injection-process-builder.java", "category": "historical", "splited_testsuite_b": ["public class TestExecutor {\n\n    private Pair<Integer, String> test1(String command, Logger logAppender) throws IOException {\n      String[] cmd = new String[3];\n      String osName = System.getProperty(\"os.name\");\n      if (osName.startsWith(\"Windows\")) {\n          cmd[0] = \"cmd.exe\";\n          cmd[1] = \"/C\";\n      } else {\n          cmd[0] = \"/bin/bash\";\n          cmd[1] = \"-c\";\n      }\n      cmd[2] = command;\n\n      // ruleid: command-injection-process-builder\n      ProcessBuilder builder = new ProcessBuilder(cmd);\n      builder.redirectErrorStream(true);\n      Process proc = builder.start();\n      return Pair.newPair(1, \"Killed\");\n    }\n\n}", "public class TestExecutor {\n\n    public String test2(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test3(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"bash\", \"-c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "public class TestExecutor {\n\n    public String okTest() {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ok: command-injection-process-builder\n      builder.command(\"bash\", \"/c\", \"ls\");\n      return \"foo\";\n    }\n\n}"], "actual": [true, true, true, false, false], "expected": [true, true, true, true, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n\n```\nThe false negative example is as follows:\n```java\npublic class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: command-injection-process-builder\n  languages:\n  - java\n  message: A formatted or concatenated string was detected in a ProcessBuilder call,\n    which can be dangerous if user-controlled and lead to command injection. Ensure\n    variables are not user-controlled or properly sanitized.\n  pattern-either:\n  - patterns:\n    - pattern: 'new ProcessBuilder($CMD,...)\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern: '$PB.command($CMD,...)\n\n        '\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = \"...\";\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = Arrays.asList(\"...\",...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$CMD = new String[]{\"...\",...};\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: 'new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: 'new ProcessBuilder(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: 'new ProcessBuilder(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: 'new ProcessBuilder($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: 'new ProcessBuilder(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: 'new ProcessBuilder(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n            ...\n\n            '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: 'new ProcessBuilder(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: 'new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  - patterns:\n    - pattern-either:\n      - pattern: '$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n\n          '\n      - pattern: '$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n\n          '\n      - pattern: '$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n\n          '\n      - patterns:\n        - pattern-either:\n          - pattern: '$PB.command($CMD,\"-c\",$ARG,...)\n\n              '\n          - pattern: '$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n\n              '\n          - pattern: '$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n\n              '\n        - pattern-either:\n          - pattern-inside: '$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n\n              ...\n\n              '\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n    - pattern-inside: '$TYPE $PB = new ProcessBuilder(...);\n\n        ...\n\n        '\n    - pattern-not-inside: '$ARG = \"...\";\n\n        ...\n\n        '\n    - pattern-not: '$PB.command(\"...\",\"...\",\"...\",...)\n\n        '\n    - pattern-not: '$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n\n        '\n    - pattern-not: '$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n\n        '\n  severity: ERROR\n", "incorrect": "public class TestExecutor {\n\n    public String test4(String userInput) {\n      ProcessBuilder builder = new ProcessBuilder();\n      // ruleid: command-injection-process-builder\n      builder.command(\"cmd\", \"/c\", userInput);\n      return \"foo\";\n    }\n\n}", "type": "fn"}, "response": "{\"id\":\"0217399798782454123a5d49f9f0056ba0f97d80b7b2edf551041\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a `ProcessBuilder` instance where the `command` method is called with a user-controlled input (`userInput`). The current rule does not catch this case because it lacks a pattern to match scenarios where the command is directly passed as a variable without being part of a list or array. To address this, we need to add a pattern that matches cases where the command includes a variable directly, such as `builder.command(\\\"cmd\\\", \\\"/c\\\", $ARG)`. This will ensure that the rule correctly identifies potential command injection vulnerabilities when user-controlled inputs are used directly in the `command` method.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\n- pattern-inside: '$CMD = \\\"cmd\\\";\\n\\n        ...\\n\\n        '\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979884,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":169,\"prompt_tokens\":1276,\"total_tokens\":1445,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```", "type": "fp"}, "response": "{\"id\":\"0217399798781472b0555455acbf1dd3051b763fdd9baee6aa170\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `CriteriaQuery` and `CriteriaBuilder` which are part of the JPA (Java Persistence API) and are designed to create type-safe queries. These queries are not vulnerable to SQL injection because they use parameterized queries internally. The current rule incorrectly flags this as a potential SQL injection vulnerability because it matches the `createQuery` method.\\n\\nTo fix this, we need to add a `pattern-not` to exclude cases where `createQuery` is used with `CriteriaQuery`. This will ensure that the rule does not flag type-safe JPA queries as potential SQL injection vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not: $EM.createQuery($CRITERIA_QUERY)\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979899,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":572,\"prompt_tokens\":778,\"total_tokens\":1350,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```", "type": "fp"}, "response": "{\"id\":\"0217399798778387549dffca8895f14e3c2bdf728d3ba38725b1c\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a method that uses `CriteriaQuery` and `CriteriaBuilder` to construct a SQL query in a safe manner, which does not involve string formatting or concatenation. The current rule incorrectly flags this as a potential SQL injection vulnerability. To prevent this false positive, we need to add a `pattern-not-inside` clause that excludes cases where `CriteriaQuery` and `CriteriaBuilder` are used. This will ensure that the rule does not flag safe usage of these JPA (Java Persistence API) constructs.\\n\\nThe new pattern will exclude cases where `CriteriaQuery` and `CriteriaBuilder` are used, as these are safe and do not involve string formatting or concatenation.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: |\\n            $EM.createQuery($QUERY.where($CRITERIABUILDER.equal($...)))\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979901,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":602,\"prompt_tokens\":778,\"total_tokens\":1380,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```", "type": "fp"}, "response": "{\"id\":\"0217399798782431b41ddce50374106f9832e08fc27e0aaf7c45f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a method `addWhere` that uses `EntityManager` to create a query with `CriteriaBuilder`. This is a safe way to construct SQL queries as it uses parameterized queries, which are not vulnerable to SQL injection. The current rule incorrectly flags this as a potential SQL injection because it matches the pattern of using `EntityManager` to create a query. To prevent this false positive, we need to add a `pattern-not-inside` that excludes cases where `CriteriaBuilder` is used to construct the query. This will ensure that the rule only flags unsafe SQL query constructions.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: |\\n            $EM.createQuery($QUERY.where($CRITERIA.equal($ROOT.get($FIELD), $INPUT)))\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979901,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":586,\"prompt_tokens\":778,\"total_tokens\":1364,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```", "type": "fp"}, "response": "{\"id\":\"021739979878164164a27376a8ae6eee5d7d6e4957324666ab6a5\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `CriteriaQuery` used with `EntityManager.createQuery`, which is a safe way to construct SQL queries and does not lead to SQL injection. The current rule incorrectly flags this as a potential SQL injection vulnerability. To fix this, we need to add a `pattern-not-inside` clause to exclude cases where `EntityManager.createQuery` is used with `CriteriaQuery`. This will ensure that such safe usages are not flagged as vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: |\\n            $EM.createQuery($CRITERIA_QUERY)\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979898,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":548,\"prompt_tokens\":778,\"total_tokens\":1326,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "formatted-sql-string", "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n", "failed_tests": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "failed_type": "fp", "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n", "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n", "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n", "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml", "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java", "category": "historical", "splited_testsuite_b": ["```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```", "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"], "actual": [false, true, true, true, true, true, true, true, true, true, false, false, false, true], "expected": [false, true, true, true, true, true, true, true, true, true, false, false, false, false], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n          - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: ERROR\n", "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```", "type": "fp"}, "response": "{\"id\":\"021739979877870af3d860f181fcba7f252ea2d6bc1813a232802\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `CriteriaQuery` being used with `EntityManager.createQuery()`, which is a safe way to construct SQL queries using JPA's Criteria API. The current rule incorrectly flags this as a potential SQL injection vulnerability because it matches the pattern of `EntityManager.$SQLFUNC(...)` without considering the context of `CriteriaQuery`.\\n\\nTo fix this, we need to add a `pattern-not-inside` clause to exclude cases where `EntityManager.createQuery()` is used with `CriteriaQuery`. This will ensure that the rule does not flag safe usage of JPA Criteria API.\\n\\nThe new pattern should be added under `pattern-sources` to exclude cases where `CriteriaQuery` is used with `EntityManager.createQuery()`.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n          - pattern-not-inside: |\\n              $EM.createQuery($CRITERIA_QUERY)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979901,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":605,\"prompt_tokens\":778,\"total_tokens\":1383,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n            ...\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-either:\n        - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n            ...\n\n            '\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "incorrect": "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987784865ccdfb1aa4d756c762a23f609eb7d361784ba\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a scenario where the `ObjectMapper` is created and configured in a method (`initialize()`) rather than directly in the same block where `readValue` is called. The current rule does not capture this because it only looks for `ObjectMapper` instantiation and configuration within the same block or inside a class with specific annotations.\\n\\nTo address this, we need to add a `pattern-inside` that captures the case where `ObjectMapper` is instantiated and configured in a different method but still used in a vulnerable manner. Specifically, we need to ensure that the rule captures the `ObjectMapper` instance regardless of where it is initialized, as long as it is used in a `readValue` call.\\n\\nBy adding a `pattern-inside` that looks for `ObjectMapper` instantiation and configuration in any method within the class, we can correctly identify the false negative example.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: jackson-unsafe-deserialization\\n  languages:\\n  - java\\n  message: '\\n\\n    When using Jackson for JSON to Java object conversion, enabling default typing\\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\\n    default typing (globally or via \\\"Per-class\\\" annotations) and refrain from using\\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\\n\\n    '\\n  patterns:\\n  - pattern-either:\\n    - patterns:\\n      - pattern-either:\\n        - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\\n\\n            ...\\n\\n            '\\n        - pattern-inside: |\\n            class $CLASS {\\n              ...\\n              $RETURN $METHOD(...) {\\n                $OM = new ObjectMapper();\\n                $OM.enableDefaultTyping();\\n                ...\\n              }\\n              ...\\n            }\\n      - pattern-inside: '$OM.enableDefaultTyping();\\n\\n          ...\\n\\n          '\\n      - pattern: $OM.readValue($JSON, ...);\\n    - patterns:\\n      - pattern-inside: \\\"class $CLASS {\\\\n  ...\\\\n  @JsonTypeInfo(use = Id.CLASS,...)\\\\n\\\\\\n          \\\\  $TYPE $VAR;\\\\n  ...\\\\n}\\\\n\\\"\\n      - metavariable-regex:\\n          metavariable: $TYPE\\n          regex: (Object|Serializable|Comparable)\\n      - pattern: $OM.readValue($JSON, $CLASS.class);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979902,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":550,\"prompt_tokens\":732,\"total_tokens\":1282,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-either:\n        - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n            \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-either:\n        - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n            \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "incorrect": "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"02173997987803299e86ceec729089a99e6ed0b29e5b8e9fa4e30\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an `ObjectMapper` instance being created and configured in a different method (`initialize()`), and then used in another method (`vulnerable()`). The current rule does not catch this because it assumes the `ObjectMapper` is created and configured in the same block where `readValue` is called. To address this, we need to add a pattern that captures the scenario where the `ObjectMapper` is created and configured in a different method but still used in the same class. We can use the `pattern-inside` tag to ensure that the `ObjectMapper` instance is used within the same class where it is created and configured.\\n\\nThe new pattern should look for the `ObjectMapper` being used in any method within the same class, regardless of where it was created or configured.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: jackson-unsafe-deserialization\\n  languages:\\n  - java\\n  message: '\\n\\n    When using Jackson for JSON to Java object conversion, enabling default typing\\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\\n    default typing (globally or via \\\"Per-class\\\" annotations) and refrain from using\\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\\n\\n    '\\n  patterns:\\n  - pattern-either:\\n    - patterns:\\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\\n\\n          ...\\n\\n          '\\n      - pattern-inside: '$OM.enableDefaultTyping();\\n\\n          ...\\n\\n          '\\n      - pattern: $OM.readValue($JSON, ...);\\n    - patterns:\\n      - pattern-either:\\n        - pattern-inside: \\\"class $CLASS {\\\\n  ...\\\\n  @JsonTypeInfo(use = Id.CLASS,...)\\\\n\\\\\\n            \\\\  $TYPE $VAR;\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-inside: |\\n            class $CLASS {\\n              ...\\n              ObjectMapper $OM = new ObjectMapper();\\n              $OM.enableDefaultTyping();\\n              ...\\n              $OM.readValue($JSON, $CLASS.class);\\n              ...\\n            }\\n      - metavariable-regex:\\n          metavariable: $TYPE\\n          regex: (Object|Serializable|Comparable)\\n      - pattern: $OM.readValue($JSON, $CLASS.class);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979897,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":534,\"prompt_tokens\":732,\"total_tokens\":1266,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "incorrect": "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979877585d415e58c096a7f34955926826fc72fa9d42cc0\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an `ObjectMapper` instance that is created and configured in a different method (`initialize()`) than where it is used (`vulnerable()`). The current rule only detects unsafe deserialization if the `ObjectMapper` is created and configured in the same block where `readValue` is called. To address this, we need to add a pattern that captures cases where the `ObjectMapper` is used for deserialization, regardless of where it was created or configured.\\n\\nWe can use the `pattern-inside` tag to ensure that the rule matches the `readValue` call even if the `ObjectMapper` was created and configured elsewhere. This will allow the rule to detect unsafe deserialization in scenarios like the false negative example.\\n\\nThe new pattern should look for the `readValue` method call on an `ObjectMapper` instance, regardless of where the `ObjectMapper` was created or configured.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: jackson-unsafe-deserialization\\n  languages:\\n  - java\\n  message: '\\n\\n    When using Jackson for JSON to Java object conversion, enabling default typing\\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\\n    default typing (globally or via \\\"Per-class\\\" annotations) and refrain from using\\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\\n\\n    '\\n  patterns:\\n  - pattern-either:\\n    - patterns:\\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\\n\\n          ...\\n\\n          '\\n      - pattern-inside: '$OM.enableDefaultTyping();\\n\\n          ...\\n\\n          '\\n      - pattern-inside: '$OM.readValue($JSON, ...);\\n\\n          ...\\n\\n          '\\n      - pattern: $OM.readValue($JSON, ...);\\n    - patterns:\\n      - pattern-inside: \\\"class $CLASS {\\\\n  ...\\\\n  @JsonTypeInfo(use = Id.CLASS,...)\\\\n\\\\\\n          \\\\  $TYPE $VAR;\\\\n  ...\\\\n}\\\\n\\\"\\n      - metavariable-regex:\\n          metavariable: $TYPE\\n          regex: (Object|Serializable|Comparable)\\n      - pattern: $OM.readValue($JSON, $CLASS.class);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979897,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":521,\"prompt_tokens\":726,\"total_tokens\":1247,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-either:\n        - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n            \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-either:\n        - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n            \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "incorrect": "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878024c038e14dcafb30bd771c014e08fe6acc4a613f\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves an `ObjectMapper` instance that is created and configured in a different method (`initialize()`) than where it is used (`vulnerable()`). The current rule does not catch this because it only looks for `ObjectMapper` creation and configuration within the same code block. To address this, we need to add a pattern that detects `ObjectMapper` usage regardless of where it is initialized or configured. This can be achieved by adding a `pattern-inside` that captures the broader context of the class, ensuring that the rule catches `ObjectMapper` usage even if it is initialized elsewhere in the class.\\n\\nThe new pattern should be added to the second `pattern-either` block to ensure that the rule catches cases where `ObjectMapper` is used in a method, regardless of where it was initialized or configured.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: jackson-unsafe-deserialization\\n  languages:\\n  - java\\n  message: '\\n\\n    When using Jackson for JSON to Java object conversion, enabling default typing\\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\\n    default typing (globally or via \\\"Per-class\\\" annotations) and refrain from using\\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\\n\\n    '\\n  patterns:\\n  - pattern-either:\\n    - patterns:\\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\\n\\n          ...\\n\\n          '\\n      - pattern-inside: '$OM.enableDefaultTyping();\\n\\n          ...\\n\\n          '\\n      - pattern: $OM.readValue($JSON, ...);\\n    - patterns:\\n      - pattern-either:\\n        - pattern-inside: \\\"class $CLASS {\\\\n  ...\\\\n  @JsonTypeInfo(use = Id.CLASS,...)\\\\n\\\\\\n            \\\\  $TYPE $VAR;\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-inside: |\\n            class $CLASS {\\n              ...\\n              $OM.readValue($JSON, $CLASS.class);\\n              ...\\n            }\\n      - metavariable-regex:\\n          metavariable: $TYPE\\n          regex: (Object|Serializable|Comparable)\\n      - pattern: $OM.readValue($JSON, $CLASS.class);\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979898,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":519,\"prompt_tokens\":732,\"total_tokens\":1251,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
{"id": "jackson-unsafe-deserialization", "rule": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n  severity: WARNING\n", "failed_tests": ["// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "failed_type": "fp", "testsuite_a": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        //objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "testsuite_b": "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}\n\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "ground_truth": "rules:\n  - id: jackson-unsafe-deserialization\n    patterns:\n      - pattern-either:\n          - patterns:\n              - pattern-inside: |\n                  ObjectMapper $OM = new ObjectMapper(...);\n                  ...\n              - pattern-inside: |\n                  $OM.enableDefaultTyping();\n                  ...\n              - pattern: $OM.readValue($JSON, ...);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    @JsonTypeInfo(use = Id.CLASS,...)\n                    $TYPE $VAR;\n                    ...\n                  }\n              - metavariable-regex:\n                  metavariable: $TYPE\n                  regex: (Object|Serializable|Comparable)\n              - pattern: $OM.readValue($JSON, $CLASS.class);\n          - patterns:\n              - pattern-inside: |\n                  class $CLASS {\n                    ...\n                    ObjectMapper $OM;\n                    ...\n                    $INITMETHODTYPE $INITMETHOD(...) {\n                      ...\n                      $OM = new ObjectMapper();\n                      ...\n                      $OM.enableDefaultTyping();\n                      ...\n                    }\n                    ...\n                  }\n              - pattern-inside: |\n                  $METHODTYPE $METHOD(...) {\n                    ...  \n                  }\n              - pattern: $OM.readValue($JSON, ...);\n    message: >-\n      When using Jackson to marshall/unmarshall JSON to Java objects,\n      enabling default typing is dangerous and can lead to RCE. If an attacker\n      can control `$JSON` it might be possible to provide a malicious JSON which\n      can be used to exploit unsecure deserialization. In order to prevent this\n      issue, avoid to enable default typing (globally or by using \"Per-class\"\n      annotations) and avoid using `Object` and other dangerous types for member\n      variable declaration which creating classes for Jackson based\n      deserialization.\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      category: security\n      subcategory:\n        - audit\n      cwe:\n        - \"CWE-502: Deserialization of Untrusted Data\"\n      confidence: MEDIUM\n      likelihood: LOW\n      impact: HIGH\n      owasp:\n        - A8:2017 Insecure Deserialization\n        - A8:2021 Software and Data Integrity Failures\n      references:\n        - https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038\n        - https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062\n        - https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/\n      technology:\n        - jackson\n", "rule_path": "extend_dataset/fe553ed1/before/jackson-unsafe-deserialization.yaml", "test_path": "extend_dataset/fe553ed1/after/jackson-unsafe-deserialization.java", "category": "historical", "splited_testsuite_b": ["private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        // Disable default typing globally\n        // objectMapper.enableDefaultTyping();\n\n        try {\n            // ruleid: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Car.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "private class Car {\n    private Fake variable;\n\n    @JsonTypeInfo(use = Id.CLASS)\n    private Object color;\n    private String type;\n\n    public Car() {\n    }\n\n    public Car(Object color, String type) {\n        this.color = color;\n        this.type = type;\n    }\n\n    public String getColor() {\n        return (String) this.color;\n    }\n\n    public void setColor(Object color) {\n        this.color = color;\n    }\n\n    public String getType() {\n        return this.type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public static void anotherMain2(String[] args) throws JsonGenerationException, JsonMappingException, IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        try {\n            // ok: jackson-unsafe-deserialization\n            Car car = objectMapper.readValue(Paths.get(\"target/payload.json\").toFile(), Another.class);\n            System.out.println((car.getColor()));\n        } catch (Exception e) {\n            System.out.println(\"Exception raised:\" + e.getMessage());\n        }\n\n    }\n}", "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}"], "actual": [true, true, false, false], "expected": [true, true, false, true], "prompt": {"prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false negative example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n\n```\nThe false negative example is as follows:\n```java\n// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n", "template": "rules:\n- id: jackson-unsafe-deserialization\n  languages:\n  - java\n  message: '\n\n    When using Jackson for JSON to Java object conversion, enabling default typing\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\n    default typing (globally or via \"Per-class\" annotations) and refrain from using\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\n\n    '\n  patterns:\n  - pattern-either:\n    - patterns:\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\n\n          ...\n\n          '\n      - pattern-inside: '$OM.enableDefaultTyping();\n\n          ...\n\n          '\n      - pattern: $OM.readValue($JSON, ...);\n    - patterns:\n      - pattern-inside: \"class $CLASS {\\n  ...\\n  @JsonTypeInfo(use = Id.CLASS,...)\\n\\\n          \\  $TYPE $VAR;\\n  ...\\n}\\n\"\n      - metavariable-regex:\n          metavariable: $TYPE\n          regex: (Object|Serializable|Comparable)\n      - pattern: $OM.readValue($JSON, $CLASS.class);\n      - <PATTERN>: <GENERATE A PATTERN HERE>\n  severity: WARNING\n", "incorrect": "// Additional class to test rule when ObjectMapper is created in a different\n// method\n@RestController\npublic class MyController {\n    private Test variable;\n    private ObjectMapper objectMapper;\n    private Test2 variable2;\n\n    @PostConstruct\n    public void initialize() {\n        this.variable = 123;\n        objectMapper = new ObjectMapper();\n        objectMapper.enableDefaultTyping();\n        this.variable2 = 456;\n    }\n\n    @RequestMapping(path = \"/\", method = RequestMethod.GET)\n    public void redirectToUserInfo(HttpServletResponse response) throws IOException {\n        response.sendRedirect(\"/somewhere\");\n    }\n\n    @RequestMapping(path = \"/vulnerable\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    public GenericUser vulnerable(@CookieValue(name = \"token\", required = false) String token)\n            throws JsonParseException, JsonMappingException, IOException {\n        byte[] decoded = Base64.getDecoder().decode(token);\n        String decodedString = new String(decoded);\n        // ruleid: jackson-unsafe-deserialization\n        Car obj = objectMapper.readValue(\n                decodedString,\n                Car.class);\n        return obj;\n    }\n}", "type": "fn"}, "response": "{\"id\":\"021739979878064c2649323859df38f4624a67d95e98392f8090a\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false negative example involves a scenario where the `ObjectMapper` is created and configured in a different method (`initialize()`), and the `readValue` method is called in another method (`vulnerable()`). The current rule does not capture this because it expects the `ObjectMapper` creation and configuration to be in the same block as the `readValue` call.\\n\\nTo address this, we need to add a `pattern-inside` to ensure that the rule captures cases where the `ObjectMapper` is configured with `enableDefaultTyping()` even if it happens in a different method. This will allow the rule to match the `readValue` call regardless of where the `ObjectMapper` was configured.\\n\\nThe new `pattern-inside` should look for the `enableDefaultTyping()` call anywhere in the class, not just immediately before the `readValue` call.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: jackson-unsafe-deserialization\\n  languages:\\n  - java\\n  message: '\\n    When using Jackson for JSON to Java object conversion, enabling default typing\\n    poses a significant risk of RCE. If an attacker controls `$JSON`, they could supply\\n    malicious JSON to exploit insecure deserialization. To mitigate this, avoid enabling\\n    default typing (globally or via \\\"Per-class\\\" annotations) and refrain from using\\n    `Object` and other unsafe types in class member declarations for Jackson deserialization.\\n    '\\n  patterns:\\n  - pattern-either:\\n    - patterns:\\n      - pattern-inside: 'ObjectMapper $OM = new ObjectMapper(...);\\n          ...\\n          '\\n      - pattern-inside: '$OM.enableDefaultTyping();\\n          ...\\n          '\\n      - pattern: $OM.readValue($JSON, ...);\\n    - patterns:\\n      - pattern-inside: \\\"class $CLASS {\\\\n  ...\\\\n  @JsonTypeInfo(use = Id.CLASS,...)\\\\n\\\\\\n          \\\\  $TYPE $VAR;\\\\n  ...\\\\n}\\\\n\\\"\\n      - metavariable-regex:\\n          metavariable: $TYPE\\n          regex: (Object|Serializable|Comparable)\\n      - pattern: $OM.readValue($JSON, $CLASS.class);\\n      - pattern-inside: |\\n          class $CLASS {\\n            ...\\n            $OM.enableDefaultTyping();\\n            ...\\n          }\\n  severity: WARNING\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979900,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":517,\"prompt_tokens\":726,\"total_tokens\":1243,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}"}
