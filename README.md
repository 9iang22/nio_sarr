This repo is for static analysis refinement project of nio.

# Quick Start
Using Docker to quickly reproduce the evaluations.

## Build Docker image and start a container
```
docker build -t sarr .
docker run --rm -it sarr:latest
```

## Install python deps.
```
python3 -m venv ./sarr
source ./sarr/bin/activate
```

## Set your DeepSeek API KEY
The default code uses API service from 火山模型.
```
export DOUBAO_APIKEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```
To change it to DeepSeek API service, modify the following lines in `semgrep_pipeline.py`
```
from doubao import chat
# from deepseek import chat
```
And then setup your DeepSeek API
```
export DS_APIKEY=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```
Or you can using your own API interface by import it to `semgrep_pipeline.py`
Read `doubao.py` or `deepseek.py` as examples.

## Run a small example
There is a small example for checking the pipeline.
```
python3 -m semgrep_pipeline.py -i dataset/example.jsonl -o output
python3 -m analysis_results.py -i output/verify.jsonl
```
It's expected that this case cannot pass, but there should not be CRASH, EXCEPTIONS.
## Run full dataset
If you don't have an APIKEY or just don't want to rerun the experiment, 
you can view the pre-run results under 'dataset'.

semgrep_prompts.jsonl -> the prompts we use, incluing the fault location results.
semgrep_results.jsonl -> the query results from LLMs.
semgrep_verify.jsonl -> the final results.

The following command will show the results of the refinement of semgrep java rules.
```
python3 -m analysis_results.py -i dataset/semgrep_verify.jsonl
```

The following command will rerun the experiment.
It will cost about 1m tokens when using DeepSeek-V3.
```
python3 -m semgrep_pipeline.py -i dataset/semgrep_java.jsonl -o output
python3 -m analysis_results.py -i output/verify.jsonl
python3 -m semgrep_pipeline.py -i dataset/semgrep_not_java.jsonl -o output2
python3 -m analysis_results.py -i output2/verify.jsonl
```

You can view the results by:
```
shuf -n1 your_output_dir/verify.jsonl | jq
```

An example
```
{
  "id": "formatted-sql-string",
  "rule": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n",
  "failed_tests": [
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"
  ],
  "failed_type": "fp",
  "testsuite_a": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n\n",
  "testsuite_b": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        \n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n",
  "ground_truth": "rules:\n- id: formatted-sql-string\n  metadata:\n    cwe:\n    - \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n    owasp:\n    - A01:2017 - Injection\n    - A03:2021 - Injection\n    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION\n    asvs:\n      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'\n      control_id: 5.3.5 Injection\n      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements\n      version: '4'\n    references:\n    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps\n    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\n    category: security\n    technology:\n    - java\n    cwe2022-top25: true\n    cwe2021-top25: true\n    subcategory:\n    - vuln\n    likelihood: HIGH\n    impact: MEDIUM\n    confidence: MEDIUM\n  message: >-\n    Detected a formatted string in a SQL statement. This could lead to SQL\n    injection if variables in the SQL statement are not properly sanitized.\n    Use a prepared statements (java.sql.PreparedStatement) instead. You\n    can obtain a PreparedStatement using 'connection.prepareStatement'.\n  mode: taint\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          (HttpServletRequest $REQ)\n      - patterns:\n        - pattern-inside: |\n            $ANNOT $FUNC (..., $INPUT, ...) {\n              ...\n            }\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sanitizers:\n  - patterns:\n    - pattern: (CriteriaBuilder $CB).$ANY(...)\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  severity: ERROR\n  languages:\n  - java\n",
  "rule_path": "extend_dataset/9658b2f5/before/formatted-sql-string.yaml",
  "test_path": "extend_dataset/9658b2f5/after/formatted-sql-string.java",
  "category": "historical",
  "splited_testsuite_b": [
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample2 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SQLExample3 {\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\"\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n}\n```",
    "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```"
  ],
  "actual": [
    false,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    false,
    false,
    false,
    true
  ],
  "expected": [
    false,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    true,
    false,
    false,
    false,
    false
  ],
  "prompt": {
    "prompt": "Here is a semgrep rule to be modified, and there is an incorrect example for it. \nPlease select a pattern tag from [\"pattern\", \"pattern-not\", \"pattern-inside\", \"pattern-not-inside\"] \nand add a new pattern at the <GENERATE A PATTERN HERE> position so that the entire rule can correctly classify the originally false positive example. \nThe semgrep rule to be modified is as follows:\n```yaml\nrules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n\n```\nThe false positive example is as follows:\n```java\n```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```\n```\nThe answer should follow the format below:\n<EXPLANATION>\nYOUR_EXPLANATION_HERE\n</EXPLANATION>\n\n<FINAL_ANSWER>\n```yaml\nYOUR_FINAL_ANSWER_HERE\n```\n</FINAL_ANSWER>\n",
    "template": "rules:\n- id: formatted-sql-string\n  languages:\n  - java\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\n    instead, obtained via 'connection.prepareStatement'.\n  mode: taint\n  pattern-sanitizers:\n  - patterns:\n    - focus-metavariable: $...X\n    - pattern-either:\n      - pattern: <... $...X != $...Y ...>\n      - pattern: <... $...Y != $...X ...>\n      - pattern: <... $...X == $...Y ...>\n      - pattern: <... $...Y == $...X ...>\n  pattern-sinks:\n  - patterns:\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)\n    - pattern-not: $S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)\n    - pattern-either:\n      - pattern: (Statement $S).$SQLFUNC(...)\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\n    - metavariable-regex:\n        metavariable: $SQLFUNC\n        regex: execute|executeQuery|createQuery|query\n  pattern-sources:\n  - patterns:\n    - pattern-either:\n      - pattern: '(HttpServletRequest $REQ)\n\n          '\n      - patterns:\n        - pattern-inside: \"$ANNOT $FUNC (..., $INPUT, ...) {\\n  ...\\n}\\n\"\n        - <PATTERN>: <GENERATE A PATTERN HERE>\n        - pattern-either:\n          - pattern: (String $INPUT)\n          - pattern: String.format(..., (String $INPUT), ...)\n  severity: ERROR\n",
    "incorrect": "```java\n// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class FalsePositiveCase {\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n```",
    "type": "fp"
  },
  "response": "{\"id\":\"021739979878164164a27376a8ae6eee5d7d6e4957324666ab6a5\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"<EXPLANATION>\\nThe false positive example involves a `CriteriaQuery` used with `EntityManager.createQuery`, which is a safe way to construct SQL queries and does not lead to SQL injection. The current rule incorrectly flags this as a potential SQL injection vulnerability. To fix this, we need to add a `pattern-not-inside` clause to exclude cases where `EntityManager.createQuery` is used with `CriteriaQuery`. This will ensure that such safe usages are not flagged as vulnerabilities.\\n</EXPLANATION>\\n\\n<FINAL_ANSWER>\\n```yaml\\nrules:\\n- id: formatted-sql-string\\n  languages:\\n  - java\\n  message: Detected a formatted string in a SQL statement, which could lead to SQL\\n    injection if variables are not properly sanitized. Use a prepared statement (java.sql.PreparedStatement)\\n    instead, obtained via 'connection.prepareStatement'.\\n  mode: taint\\n  pattern-sanitizers:\\n  - patterns:\\n    - focus-metavariable: $...X\\n    - pattern-either:\\n      - pattern: <... $...X != $...Y ...>\\n      - pattern: <... $...Y != $...X ...>\\n      - pattern: <... $...X == $...Y ...>\\n      - pattern: <... $...Y == $...X ...>\\n  pattern-sinks:\\n  - patterns:\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE *$/\\\" ...>)\\n    - pattern-not: $S.$SQLFUNC(<... \\\"=~/.*TABLE %s$/\\\" ...>)\\n    - pattern-either:\\n      - pattern: (Statement $S).$SQLFUNC(...)\\n      - pattern: (Connection $C).createStatement(...).$SQLFUNC(...)\\n      - pattern: (EntityManager $EM).$SQLFUNC(...)\\n    - metavariable-regex:\\n        metavariable: $SQLFUNC\\n        regex: execute|executeQuery|createQuery|query\\n  pattern-sources:\\n  - patterns:\\n    - pattern-either:\\n      - pattern: '(HttpServletRequest $REQ)\\n\\n          '\\n      - patterns:\\n        - pattern-inside: \\\"$ANNOT $FUNC (..., $INPUT, ...) {\\\\n  ...\\\\n}\\\\n\\\"\\n        - pattern-not-inside: |\\n            $EM.createQuery($CRITERIA_QUERY)\\n        - pattern-either:\\n          - pattern: (String $INPUT)\\n          - pattern: String.format(..., (String $INPUT), ...)\\n  severity: ERROR\\n```\\n</FINAL_ANSWER>\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739979898,\"model\":\"deepseek-v3-241226\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":548,\"prompt_tokens\":778,\"total_tokens\":1326,\"completion_tokens_details\":{\"audio_tokens\":null,\"reasoning_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":null,\"cached_tokens\":0}}}",
  "verify_result": [
    "REFINE_SUCCESS"
  ]
}
```
The `verify_result` indicate the results of refined rules.

